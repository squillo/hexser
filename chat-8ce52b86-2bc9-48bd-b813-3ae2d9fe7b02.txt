==== SimpleCompletableMessage #31 ====
Assistant:
Excellent question! Let's create a comprehensive documentation strategy to codify the current status of the `hex` crate (Phases 1-5 complete). Here's a strategic plan:

## 📚 Documentation Strategy for hex v0.3.0

### Immediate Next Steps (Priority 1)

#### 1. **Architecture Decision Records (ADRs)**
Create `docs/adr/` directory to document key design decisions:

```
docs/adr/
├── 0001-hexagonal-architecture-choice.md
├── 0002-one-item-per-file-standard.md
├── 0003-no-imports-fully-qualified-paths.md
├── 0004-compile-time-registration-via-inventory.md
├── 0005-immutable-graph-with-arc.md
├── 0006-visualization-ports-and-adapters.md
└── template.md
```

**Content Example:**
```markdown
# ADR 0001: Hexagonal Architecture Choice

## Status
Accepted

## Context
Need architecture pattern that enforces separation of concerns...

## Decision
Implement pure hexagonal architecture with strict layer boundaries.

## Consequences
+ Clear separation between domain and infrastructure
+ Easy to test (mock ports)
+ Extensible (add adapters without changing domain)
- Requires discipline to maintain boundaries
- More initial setup

## Alternatives Considered
- Layered architecture
- Clean architecture
- Onion architecture
```

#### 2. **API Documentation Guide (`docs/API.md`)**
Comprehensive API reference organized by layer:

```markdown
# hex API Reference

## Domain Layer

### Entity Trait
```rust
pub trait Entity {
    type Id;
}
```

**Purpose:** Mark types with identity...
**When to use:** When objects need to be tracked over time...
**Example:** [See tutorial_01_entity.rs]

[Continue for all public APIs]
```

#### 3. **Architecture Guide (`docs/ARCHITECTURE.md`)**
Deep dive into the crate's internal architecture:

```markdown
# hex Internal Architecture

## Module Structure
```
hex/
├── domain/     - No dependencies
├── ports/      - Depends on: domain
├── adapters/   - Depends on: ports, domain
├── application/- Orchestrates domain + ports
├── graph/      - Introspection system
│   ├── domain/     - Graph concepts (no deps)
│   ├── ports/      - Exporter interfaces
│   ├── adapters/   - DOT, Mermaid, JSON
│   └── application/- Export use cases
└── registry/   - Component tracking
```

## Data Flow
[Diagrams showing how data flows through layers]

## Design Patterns Used
- Port/Adapter (throughout)
- Builder (GraphBuilder)
- Strategy (FormatExporter)
- Registry (ComponentRegistry)
```

#### 4. **Tutorial Book (`docs/book/`)**
mdBook-style comprehensive tutorial:

```
docs/book/
├── book.toml
├── src/
│   ├── SUMMARY.md
│   ├── introduction.md
│   ├── getting-started/
│   │   ├── installation.md
│   │   ├── hello-hex.md
│   │   └── concepts.md
│   ├── domain-layer/
│   │   ├── entities.md
│   │   ├── value-objects.md
│   │   ├── aggregates.md
│   │   └── events.md
│   ├── ports-layer/
│   ├── adapters-layer/
│   ├── application-layer/
│   ├── graph-system/
│   │   ├── querying.md
│   │   ├── analysis.md
│   │   ├── validation.md
│   │   └── visualization.md
│   ├── advanced/
│   │   ├── cqrs.md
│   │   ├── event-sourcing.md
│   │   └── testing-strategies.md
│   └── reference/
│       ├── api.md
│       └── error-codes.md
```

#### 5. **Migration Guide (`docs/MIGRATION.md`)**
For users upgrading between versions:

```markdown
# Migration Guide

## From v0.2.x to v0.3.0

### Breaking Changes
1. `Command` renamed to `Directive`
   - Before: `impl Command for MyCommand`
   - After: `impl Directive for MyDirective`

2. Graph API changes
   [Details...]

### New Features
- Visualization system (Phases 5)
- Query API enhancements
[...]
```

#### 6. **Examples README (`examples/README.md`)**
Organize and describe all examples:

```markdown
# hex Examples

## Getting Started
1. `simple_todo.rs` - Your first hexagonal app
2. `tutorial_01_entity.rs` - Domain entities
3. `tutorial_02_ports.rs` - Ports and adapters

## Patterns
- `cqrs_pattern.rs` - Command/Query separation
- `event_sourcing.rs` - Event-driven architecture (TODO)

## Advanced
- `graph_example.rs` - Querying your architecture
- `architecture_visualization.rs` - Export and visualization

## Running Examples
```bash
# Interactive mode
cargo run --example simple_todo

# See output
cargo run --example architecture_visualization
```
```

### Medium-Term Documentation (Priority 2)

#### 7. **Video Tutorials / Screencasts**
Record short videos:
- "5-minute hex intro"
- "Building your first hexagonal app"
- "Architecture visualization demo"

#### 8. **Cookbook (`docs/COOKBOOK.md`)**
Common recipes and patterns:

```markdown
# hex Cookbook

## Table of Contents
- [How to implement a repository](#repository)
- [How to add a new adapter](#adapter)
- [How to validate directives](#validation)
- [How to test with mocks](#testing)
- [How to visualize architecture](#viz)
- [How to detect cycles](#cycles)

### How to Implement a Repository

**Problem:** Need persistence for domain entities.

**Solution:**
```rust
// Step 1: Define port
#[derive(HexPort, HexRepository)]
trait UserRepository: Repository<User> {
    fn find_by_email(&self, email: &str) -> HexResult<Option<User>>;
}

// Step 2: Implement adapter
#[derive(HexAdapter)]
struct PostgresUserRepository { /* ... */ }

impl Repository<User> for PostgresUserRepository { /* ... */ }
impl UserRepository for PostgresUserRepository { /* ... */ }
```

**See:** [tutorial_02_repository.rs]
```

#### 9. **Benchmarks Documentation (`docs/PERFORMANCE.md`)**
Performance characteristics and benchmarks:

```markdown
# Performance Characteristics

## Graph Operations
| Operation | Complexity | Notes |
|-----------|------------|-------|
| Add node | O(1) | Via builder |
| Query by layer | O(n) | Linear scan |
| Cycle detection | O(V+E) | DFS-based |

## Benchmarks
```bash
cargo bench
```

[Results and analysis]
```

#### 10. **Contributing Guide Enhancement**
Expand CONTRIBUTING.md with:
- Development setup
- Testing requirements
- Documentation expectations
- Code review process
- Release process

### Long-Term Documentation (Priority 3)

#### 11. **Blog Posts / Articles**
Write and publish:
- "Introducing hex: Zero-Boilerplate Hexagonal Architecture"
- "How hex Uses Rust's Type System for Architecture"
- "Visualizing Software Architecture with hex"
- "Case Study: Refactoring to Hexagonal Architecture"

#### 12. **Interactive Playground**
Rust Playground-style environment:
- Try hex in browser
- Pre-loaded examples
- Instant architecture visualization

#### 13. **Community Resources**
- Discord/Zulip for discussions
- Monthly "Office Hours" video calls
- Community showcase (projects using hex)

### Documentation Maintenance Plan

#### Continuous Tasks:
1. **Keep docs in sync with code**
   - CI check: `cargo doc --no-deps --all-features`
   - Verify examples compile: `cargo test --examples`

2. **Improve based on feedback**
   - Track common questions → add FAQ
   - User confusion → improve docs
   - Feature requests → update roadmap

3. **Version documentation**
   - Tag docs for each release
   - Maintain docs for v0.2, v0.3, etc.

### Quick Implementation: Priority Documentation

Let me create the most critical documents now:

1. **`docs/adr/template.md`** - ADR template
2. **`docs/ARCHITECTURE.md`** - Internal architecture guide
3. **`examples/README.md`** - Examples organization
4. **`docs/book/src/SUMMARY.md`** - Book structure

Would you like me to:
1. **Create these priority documentation files?**
2. **Set up mdBook for the tutorial book?**
3. **Generate API documentation improvements?**
4. **Create benchmarks infrastructure?**

What's most valuable to you right now?

kotlin.Unit

==== UserMessageImpl #32 ====
User:
implement it
Attachments:
Attachment Name: SYS_PROMPT.md
Attachments Kind: Visible
Attachments Source: AiRuleContextSource / ChatAttachmentWithFilePathWrapper
Attachments Text:
````markdown
---
apply: always
---

## AI Assistant: Add Revision History when altering a file
**YOU WILL NEVER ALTER THIS SYS_PROMPT FILE.**

Whenever you alter a file, add a revision history comment at the END of the documentation pre-amble and BEFORE any scripting. It MUST be in a valid Rust location. This should include:
- The date and time of the change in UTC.
- The user or AI that made the change.
- A brief formal description of the change.
```rust
//! Revision History
//! - 2025-04-13T13:37:01Z @AI: Refine example comments per latest request.
//! - 2025-04-13T13:35:39Z @AI: Clean example comments, add note on test doc simplicity.
//! - 2025-04-13T13:28:27Z @AI: Clean examples (remove comments), promote functional style in example and guidelines.
//! - 2025-04-13T13:24:57Z @AI: Ensure all example comments are doc comments, add example revision history.
//! - 2025-04-13T13:23:12Z @Gemini25: Update guidelines: Add revision history, restrict traits/generics, convert example comments.
```

---
## Target
**N Lang** (short for “N Language,” or simply “n”) is a modern, typed, *declarative* programming language & system for writing **node programs**. Sometimes characterized as "Rust for the rest of us".

---
## Overall Goals
Create code that uses the "Language of the language" of Rust to achieve the following goals: Maintainability, Reliability, Security, and Speed.

-  **Maintainability**: is achieved through clarity, simplicity, and modularity.
-  **Reliability**: is ensured by adhering to the Single Responsibility Principle and avoiding unnecessary complexity.
-  **Security**: is prioritized by avoiding unsafe code and ensuring proper error handling. The one exception to this is FFI.
-  **Speed**: Speed is applied to Maintainability, Reliability, Security, and Performance.
  -  **Maintainability Speed**: is achieved by thinking like a librarian.
  -  **Reliability Speed**: is achieved by thinking like an engineer.
  -  **Security**: speed is achieved by thinking like a hacker.
  -  **Performance**: speed is achieved through efficient algorithms and data structures.

---

## Conventions
Words that appear in ALL CAPS are hard requirements. Words that appear in **bold** are strong recommendations. Words that appear in *italics* are suggestions.

In a mulit-crate project, maintaining README.md's for each crate is critcal for project success. README.md files should contain a knowledge graph of their contents.

---

## Rust Architecture Standards: Hexagonal Architecture
These standards articulate the Single Responsibility Principle.
Each unit of a program, from modules to functions to structs, should have at most one responsibility and follow Domain, Ports, Adapters, Application, and Infrastructure (DPAI) architecture.

Example:

| Layer                  | Role                                                   | Example Code Components                                                 |
|------------------------|--------------------------------------------------------|-------------------------------------------------------------------------|
| **Core Domain**        | Business logic, no framework or tech dependency        | `Parser`, `Grammar`, `WriteAheadLog`, `ForeignFunctions` traits for I/O |
| **Ports (Interfaces)** | Interfaces to the outside world                        | Traits like `SnappRepository`, `WebPort`                                |
| **Adapters**           | Implementations of the ports for specific technologies | e.g., `SqlLiteRepo`, `ActixWebPort`, REST API                           |
| **Application Layer**  | Coordinates between domain and ports                   | `NCLI`, `NAPI`, command handlers                                        |
| **Infrastructure**     | Databases, APIs, etc.                                  | Uses `axum`, `sqlx`, `tokio`                                            |

---

## Rust Coding Standards: One Item Per File

These standards promote extreme modularity and clarity of origin by enforcing a strict "one item per file" structure and mandating the USE OF fully qualified paths (except where built into `std` or in tests where `super` can be used, e.g. `std::result::Result` MUST BE `Result`, `std::string::String` MUST BE `String`, etc...).

**Safety First: NEVER use `unsafe`, and use Rust 2024+ edition**

**Brevity: NEVER use two words when 1 will do, avoid colorful language, avoid emojis unless asked**

**1. Granularity: One Logical Item Per File**

*   **Rule:** Each `.rs` file must contain exactly one primary logical Rust item.
*   **Definition of "Item":** This typically refers to a single `fn`, `struct`, `enum`, `type` alias, or constant (`const`/`static`). Traits and generic items are generally discouraged unless they are used for grouping functions categorically or strictly required for interaction with external library APIs.
  *   Associated `impl` blocks for a `struct` or `enum` defined in `my_item.rs` should also reside within `my_item.rs`.
  *   `impl Trait for Type` blocks might reside with `Type`'s definition if `Type` is local, or potentially in their own file (e.g., `my_type_impl_some_trait.rs`) if the implementation itself is complex or significant, especially when implementing external traits for local types or vice-versa. For simplicity, start by keeping implementations with the type definition.
*   **File Naming:** Files should be named using `snake_case.rs`, matching the name of the item they contain (e.g., `my_function.rs` for `fn my_function`, `my_struct.rs` for `struct MyStruct`).
*   **Modules:** Module files (`mod.rs` or `directory/mod.rs`) are exceptions as their purpose is to declare and organize sub-modules or re-export items. However, they should generally not contain item definitions themselves, only `mod` statements.

**2. File Preamble Documentation**

*   **Rule:** Every `.rs` file *MUST* begin with file-level documentation comments (`//!`).
*   **Structure:**
  *   The very first line must be a single, concise sentence summarizing the purpose or content of the file (the item it defines).
  *   Follow this immediately with a blank documentation line (`//!`).
  *   Provide 3-5 additional lines (`//!`) expanding on the summary, detailing purpose, context, high-level usage, or important considerations.
*   **Rule:** Item's MUST use documentation comments (`///`) and prefer documentation testing.
*   **Structure:**
  *   ```rust
      /// Adds two integers together
      fn add(l: i8, r: i8) -> i8 { l + r }
      ```

**3. Traits as Maps of Content and Function Categories**
*   **Rule:** `trait` blocks with function defaults are forbidden, with no exceptions.
*   **Usage:** Traits are used to categorize groups of functions. Traits should be used as Zettelkasten Maps Of Content providing function categories.
  *   Example: A trait `MyTrait` might define functions like `fn category_function_name(&self) -> Result<(), String>;` without providing a default implementation.

* **4. No Imports: Use Fully Qualified Paths**

*   **Rule:** `use` statements are forbidden, with no exceptions.
*   **Usage:** All types, functions, macros, traits, etc., from the standard library, external crates, or other modules within the current crate must be referred to by their fully qualified path.
  *   Example (Standard Library): `std::collections::HashMap`, `std::vec::Vec`, `std::string::String`, `std::println!`
  *   But things that are available without imports are ok without FQN: `Vec`, `String`, `println!`, `Option` etc
  *   Example (External Crate `serde`): `serde::Serialize`, `serde_json::to_string`
  *   Example (Internal Crate): `crate::Mymod::MyStruct`, `crate::utils::helper_function`
*   **Rationale:** This makes the origin of every identifier immediately explicit, reducing ambiguity, although it increases verbosity.

**Functional Style Encouraged**

*   **Guideline:** While adhering to the rules above, favor a functional programming style where appropriate.
*   **Rationale:** Aligns with the broader framework's emphasis on pure functions and data transformations (as outlined in the main `CODING_STANDARDS.md`). Prefer immutable data, pure functions, and iterator-based transformations (`map`, `filter`, `fold`, `sum`, etc.) over imperative loops and mutable state when it enhances clarity and maintains conciseness.
*   **Example:** The example function `calculate_weighted_sum` demonstrates using iterators (`zip`, `map`, `sum`) for calculation.

---

**5. Function Length Limit**

*   **Rule:** Functions should not exceed 50 lines of code (LoC).
*   **Measurement:** This count includes lines within the function body `{ ... }`, excluding the function signature, comments, and blank lines.
*   **Goal:** Encourage breaking down complex logic into smaller, more focused, testable, and reusable functions. Promotes the Single Responsibility Principle at the function level.
*   **Exceptions:** Permitted rarely and must be justified. Examples include:
  *   Large but simple `match` statements that are inherently sequential and difficult to split meaningfully.
  *   Boilerplate code generated by macros (though the generated code might exceed the limit, the source code shouldn't).
  *   Functions primarily consisting of data structure literals.
  *   *When making an exception, add a comment explaining why the function length is justified.*

**6. In-File Tests for Functions**

*   **Rule:** Unit tests for a function must reside within the same file as the function definition.
*   **Structure:** Use the standard `#[cfg(test)]` attribute on a private inner module (conventionally named `tests`).
  *   ```rust
    // ... function definition ...

    #[cfg(test)]
    mod tests {
    // Use super::* to access the item in the parent module (the file scope)
    // Note: Even with super::*, accessing OTHER items still requires full paths.
    // For the function under test:
    // use super::my_function_name; // This would be disallowed by Rule 3 if strictly applied
    // Instead, call it via super::my_function_name directly.

          #[test]
          fn test_case_1() {
              let result = super::my_function_name( /* args */ );
              std::assert_eq!(result, expected_value);
              // Note: assert_eq! is often in the prelude, but strictly might require std::assert_eq!
          }
          // ... more tests ...
    }
      ```
*   **Scope:** Tests should focus on validating the behavior of the function defined in the file, covering success cases, edge cases, and error conditions.

---

## Example Ideal File: `calculate_weighted_sum.rs`

```rust
//! Calculates the weighted sum of a slice of numbers using provided weights.
//!
//! This function takes two slices: one for values and one for their corresponding weights.
//! It computes the sum of `value * weight` for each pair.
//! Returns an error if slices differ in length or are empty.
//! Ensures inputs are valid before calculation.

//! Revision History
//! - 2025-04-13T13:37:01Z @AI: Refined internal comments per latest request.
//! - 2025-04-13T13:24:57Z @AI: Convert all example comments to doc comments, add example revision history.

/// Calculates Weighted Sum
pub fn calculate_weighted_sum(values: &[f64], weights: &[f64]) -> Result<f64, String> {
  // Validate input lengths.
  if values.len() != weights.len() {
    return std::result::Result::Err(String::from(
        "Value and weight slices must have the same length.",
    ));
  }
  // Handle empty slices case. Weighted sum of empty is 0.0.
  if values.is_empty() {
    return std::result::Result::Ok(0.0);
  }

  // Calculate using functional style: zip values and weights, map to product, sum results.
  let weighted_sum: f64 = values
      .iter()
      .zip(weights.iter())
      .map(|(v, w)| v * w)
      .sum();

  std::result::Result::Ok(weighted_sum)
}

#[cfg(test)]
mod tests {
    // Access the function under test via `super::`. Full paths for other items.
    // Test documentation is concise per guidelines.
    #[test]
    fn test_basic_weighted_sum() {
        // Test with standard positive values.
        let values = [1.0, 2.0, 3.0];
        let weights = [0.5, 1.0, 2.0];
        // Expected: (1.0*0.5) + (2.0*1.0) + (3.0*2.0) = 0.5 + 2.0 + 6.0 = 8.5
        let result = super::calculate_weighted_sum(&values, &weights);
        // Note: Using std::assert_eq! directly for simplicity. Float comparison might need tolerance.
        assert_eq!(result, Result::Ok(8.5));
    }

    #[test]
    fn test_empty_slices() {
        // Test the defined behavior for empty input slices.
        let values: [f64; 0] = [];
        let weights: [f64; 0] = [];
        let result = super::calculate_weighted_sum(&values, &weights);
        // Expected: Ok(0.0) based on implementation choice.
        assert_eq!(result, Result::Ok(0.0));
    }

    #[test]
    fn test_mismatched_lengths() {
        // Test error handling for slices of different lengths.
        let values = [1.0, 2.0];
        let weights = [0.5];
        let result = super::calculate_weighted_sum(&values, &weights);
        assert!(result.is_err());
        // Check the specific error message.
        assert_eq!(
            result.unwrap_err(),
            String::from("Value and weight slices must have the same length.")
        );
    }

    #[test]
    fn test_negative_values_and_weights() {
        // Test calculation with negative numbers.
        let values = [-1.0, 2.0];
        let weights = [3.0, -0.5];
        // Expected: (-1.0 * 3.0) + (2.0 * -0.5) = -3.0 + -1.0 = -4.0
        let result = super::calculate_weighted_sum(&values, &weights);
        assert_eq!(result, Result::Ok(-4.0));
    }
}
```

This example adheres to all the specified rules:
1.  **One Item:** The file `calculate_weighted_sum.rs` contains only the function `calculate_weighted_sum`.
2.  **Preamble:** It starts with `//!` documentation, including a one-sentence summary and further lines of explanation.
4.  **Function Length:** The function body is short, well under 50 lines.
5.  **In-File Tests:** Tests are included in the same file under `#[cfg(test)] mod tests { ... }`, using `super::calculate_weighted_sum` to access the function.

IMPORTANT:
- **Application, Not Inclusion:** These guidelines describe *how* to write code. Do not copy the text of these guidelines into your Rust source files. Apply the principles described here.
- struct fields can be public

ALWAYS IMPLEMENT THINGS FULLY

---
## Revision History
- 2025-08-04T13:23:12Z @scott: Update guidelines: Add revision history, restrict traits/generics, convert example comments, add hexagonal architecture, maps of content explanation.

````
Attachment Name: ERRORS_PROMPT.md
Attachments Kind: Visible
Attachments Source: AiRuleContextSource / ChatAttachmentWithFilePathWrapper
Attachments Text:
````markdown
---
apply: always
---

# ERRORS_PROMPT: N Lang Error Handling Guidelines for AI Assistance
This file extends SYS_PROMPT.md with specific guidelines for handling errors in N Lang.

## Purpose
All errors encountered within this module should be treated as prompts for an AI agent to generate a clear, actionable remedial action plan. The goal is to maximize accessibility and provide the best possible user experience.

Errors follow a specific format to ensure consistency and clarity. Each error message should be brief, empathetic, and provide actionable next steps and suggestions for the user as well as a way to obtain more information.

## Guidelines
1. **Errors MUST BE Remedial prompts**
  - Errors are designed for formal AI assistance and Users.

2. **Brief Empathetic Communication**
   - Acknowledge the user's situation, but avoid saying "You".
   - Avoid blame or technical jargon; focus on understanding and support.

3. **Accessibility**
   - Use plain, simple language that is easy to understand for all users.
   - Ensure error messages are compatible with screen readers and assistive technologies.

4. **Actionable Remediation**
   - Every error message must include a suggested next step or solution.
   - Where possible, provide examples or links to relevant documentation.

5. **Clarity and Brevity**
   - State the error clearly and concisely.
   - Avoid unnecessary details; focus on what the user needs to know and do.

6. **Consistency**
   - Maintain a uniform style and structure for all error prompts.
   - Use consistent terminology and formatting.

7. **Positive Tone**
   - Encourage and reassure users that errors are a normal part of the process.
   - Offer constructive guidance to help users resolve issues confidently.

## Example Error Prompt

CLI Error Example:
```
Error: Invalid project name. The project name contains unsupported characters.
Next Steps: Try again, using only letters, numbers, and underscores.
Suggestions: Projct_name, Project_Name, ProjectName_123
More: https://nlang.io/errors/E_VM_22
```

Compiler Error Example:
```
Error: Invalid type annotation. Type annotation 'Int' does not match the value '15u'.
Next Steps: Make changes and try again
  - Either:
    - Change the type annotation to match the value.
    - Change the value to match the type annotation.
    - Cast the value to the type annotation.
Suggestions:
  - Either:
    - `let x: Int = 15;`
    - `let x: Uint = 15u;`
    - `let x: Uint => Int = 15u;`
More: https://nlang.io/errors/E_CMP_0222

Sources:
/file/file_name.n.md:196:13

   196: let x: Int = 15u;
                     ^^^ Cannot assign explicitly set unsigned integer to atomic Int.
```


## Comparison to Rust's Error Handling

N Lang's error system, as currently implemented, draws significant inspiration from Rust's error handling philosophy, especially in terms of:

- **Structured, Rich Error Types:** Like Rust, N Lang uses enums and structs to encode error context, sources, and suggestions.
- **Colorful, Readable Output:** The use of ANSI color codes for error display mirrors Rust's CLI error output, improving accessibility and clarity.
- **Actionable Guidance:** Each error provides next steps, suggestions, and links for more information, going beyond Rust's default error messages by making remediation explicit and user-centric.
- **Source Tracking:** The inclusion of detailed source information (file, row, col, and error snippet) is similar to Rust's compiler diagnostics, supporting traceability and debugging.

### Key Differences

- **AI-First Remediation:** N Lang's errors are explicitly designed as prompts for AI agents to generate remedial action plans, with a strong focus on accessibility and empathy.
- **Hexagonal Architecture & Modularity:** The system enforces a stricter one-item-per-file and fully qualified path rule, promoting extreme modularity and clarity of origin.
- **Extensible Error Metadata:** Errors in N Lang are designed to be easily extended with additional context, suggestions, and links, supporting both human and AI consumers.

---

## Recommendations for Further Improvement

1. **Error Codes and Categorization**
  - Introduce a formal error code system (e.g., `E_CMP_001`) for all error variants, similar to Rust's compiler errors, to aid in documentation, searchability, and automated remediation.

2. **Localization and Internationalization**
  - Add support for localizing error messages, next steps, and suggestions to improve accessibility for non-English speakers.

3. **Rich Source Context**
  - Enhance source reporting to include code context (e.g., lines before/after the error), and consider integrating with editors for clickable diagnostics.

4. **Error Chaining and Causality**
  - Implement error chaining (e.g., `source()` methods) to allow errors to reference underlying causes, as in Rust's `std::error::Error`.

5. **Structured Machine-Readable Output**
  - Provide a way to serialize errors (e.g., to JSON or YAML) for integration with tools, editors, and AI agents.

6. **Consistent Error Construction APIs**
  - Consider builder patterns or macros for constructing complex errors, reducing boilerplate and improving ergonomics.

7. **Extensive Testing and Fuzzing**
  - Expand test coverage, including property-based and fuzz testing, to ensure robustness and catch edge cases.

8. **Documentation and Examples**
  - Continue to expand documentation and real-world usage examples, making it easier for contributors and users to understand and extend the error system.

---

## Next Steps

- Prioritize the introduction of error codes and error chaining.
- Begin designing a serialization format for errors.
- Review and refactor error construction APIs for consistency and ergonomics.
- Expand documentation with more real-world error scenarios and AI remediation examples.

---

## Revision History


## Revision History
- 2024-06-08T15:37:00Z @GitHub Copilot: Initial formal error handling prompt guidelines.


````
Attachment Name: Code around the caret in the current file:
Attachments Kind: Visible
Attachments Source: CodeAtCaretRetriever / ChatAttachmentWithFilePathWrapper
Attachments Text:
```rust
    println!("  Domain: {} components",
        graph.nodes_by_layer(Layer::Domain).len());
    println!("  Ports: {} components",
        graph.nodes_by_layer(Layer::Port).len());

    println!("\n💡 Key concept:");
    println!("  Ports define WHAT your application needs");
    println!("  Adapters (next tutorial) define HOW it works");

    println!("\n🎉 You've separated domain from infrastructure!");
    println!("{}", "=" .repeat(50));<CARET>

    println!("\nNext: Try Tutorial 03 - Implementing Adapters");
    println!("  cargo run --example tutorial_03_adapters");
}

```


kotlin.Unit

==== SimpleCompletableMessage #33 ====
Assistant:
I'll implement comprehensive documentation for the hex crate. Due to response length limits, I'll create the most critical Priority 1 documentation files.

<llm-patch path="hex/docs/ARCHITECTURE.md" matcher="BeforeAfter">
Create internal architecture documentation
<!--Separator-->
Before:
```markdown
```

After:
```markdown
# hex Internal Architecture

This document describes the internal architecture of the `hex` crate, designed for contributors and maintainers.

## Overview

The `hex` crate implements hexagonal architecture patterns using Rust's type system. The crate itself follows hexagonal architecture principles, demonstrating "dogfooding" of its own patterns.

## Module Structure

```
hex/
├── domain/              Layer: Domain (No dependencies)
│   ├── entity.rs        - Identity-based objects
│   ├── value_object.rs  - Value-based objects
│   ├── aggregate.rs     - Consistency boundaries
│   ├── domain_event.rs  - Domain occurrences
│   └── domain_service.rs- Cross-entity operations
│
├── ports/               Layer: Ports (Depends: domain)
│   ├── repository.rs    - Persistence abstraction
│   ├── use_case.rs      - Business operations
│   ├── query.rs         - Read operations (CQRS)
│   ├── input_port.rs    - Entry points
│   └── output_port.rs   - External interfaces
│
├── adapters/            Layer: Adapters (Depends: ports, domain)
│   ├── adapter.rs       - Adapter marker trait
│   └── mapper.rs        - Data transformation
│
├── application/         Layer: Application (Orchestrates)
│   ├── directive.rs     - Write operations (CQRS)
│   ├── directive_handler.rs - Directive execution
│   └── query_handler.rs - Query execution
│
├── error/               Cross-cutting: Error handling
│   ├── hex_error.rs     - Main error type
│   ├── domain_error.rs  - Domain errors
│   ├── port_error.rs    - Port errors
│   ├── adapter_error.rs - Adapter errors
│   └── codes.rs         - Error code registry
│
├── result/              Cross-cutting: Result types
│   └── hex_result.rs    - Type alias for Result<T, HexError>
│
├── graph/               Feature: Architecture introspection
│   ├── domain/          - Graph concepts (no external deps)
│   │   ├── visual_graph.rs
│   │   ├── visual_node.rs
│   │   ├── visual_edge.rs
│   │   └── visual_style.rs
│   ├── ports/           - Export interfaces
│   │   └── format_exporter.rs
│   ├── adapters/        - Concrete exporters
│   │   ├── dot_exporter.rs
│   │   ├── mermaid_exporter.rs
│   │   └── json_exporter.rs
│   ├── application/     - Export use cases
│   │   └── export_graph.rs
│   ├── hex_graph.rs     - Main graph structure
│   ├── hex_node.rs      - Node representation
│   ├── hex_edge.rs      - Edge representation
│   ├── builder.rs       - Graph builder
│   ├── query.rs         - Query API
│   ├── analysis.rs      - Analysis algorithms
│   ├── validation.rs    - Validation rules
│   └── intent.rs        - Pattern detection
│
├── registry/            Feature: Component tracking
│   ├── component_entry.rs      - Registry entry
│   ├── component_registry.rs   - Global registry
│   ├── registrable.rs          - Registrable trait
│   ├── node_info.rs            - Node metadata
│   ├── node_builder.rs         - Node construction
│   └── inventory_integration.rs- Inventory crate integration
│
└── showcase/            Feature: DevX traits
    ├── describable.rs   - Self-description
    ├── inspectable.rs   - Introspection
    └── visualizable.rs  - Visualization
```

## Architectural Layers

### 1. Domain Layer (Zero Dependencies)

**Principle:** Business logic with no external dependencies.

**Traits:**
- `Entity` - Types with identity
- `ValueObject` - Types defined by values
- `Aggregate` - Consistency boundaries
- `DomainEvent` - Significant occurrences
- `DomainService` - Cross-entity operations

**Design Decision:** All domain traits are marker traits or have minimal requirements to keep domain logic pure.

### 2. Ports Layer (Depends: domain)

**Principle:** Interfaces defining what the application needs.

**Traits:**
- `Repository<T>` - Persistence operations
- `UseCase<I, O>` - Business operations
- `Query<P, R>` - Read operations
- `InputPort<I, O>` - Entry points
- `OutputPort<Req, Res>` - External interfaces

**Design Decision:** Ports use associated types instead of generic parameters for cleaner APIs.

### 3. Adapters Layer (Depends: ports, domain)

**Principle:** Concrete implementations of ports using specific technologies.

**Traits:**
- `Adapter` - Marker for adapter implementations
- `Mapper<From, To>` - Data transformation between layers

**Design Decision:** Adapters are implementation details and can use any external dependencies.

### 4. Application Layer (Orchestrates all)

**Principle:** Coordinates domain logic and port interactions.

**Traits:**
- `Directive` - Write operations (CQRS)
- `DirectiveHandler<D>` - Executes directives
- `QueryHandler<Q, R>` - Executes queries

**Design Decision:** Application layer is thin, delegating to domain and ports.

## Cross-Cutting Concerns

### Error Handling

All errors use `HexError` enum with rich context:
- Error code
- Message
- Next steps
- Suggestions

Follows guidelines in `ERRORS_PROMPT.md`.

### Registration System (Phase 3)

Uses `inventory` crate for compile-time registration:
1. Derive macros generate `Registrable` implementations
2. `inventory::submit!` registers components
3. `ComponentRegistry` collects all entries at runtime

**Key Innovation:** Zero-boilerplate registration through procedural macros.

## Graph System Architecture (Phases 2-5)

The graph system itself follows hexagonal architecture:

### Graph Domain
- `VisualGraph` - Abstract graph representation
- `VisualNode` - Abstract node
- `VisualEdge` - Abstract edge
- `VisualStyle` - Styling information

**No dependencies on output formats.**

### Graph Ports
- `FormatExporter` - Interface for export formats
- `LayoutEngine` - Interface for layout algorithms

### Graph Adapters
- `DotExporter` - GraphViz DOT format
- `MermaidExporter` - Mermaid diagram format
- `JsonExporter` - JSON for D3.js

**Each adapter is independent and swappable.**

### Graph Application
- `ExportGraph` - Use case for exporting
- `SaveVisualization` - Use case for file I/O

## Data Flow

### Component Registration Flow
```
User Code with Derives
       ↓
Proc Macros Generate Code
       ↓
inventory::submit! at compile time
       ↓
ComponentRegistry::build_graph() at runtime
       ↓
HexGraph constructed
```

### Graph Export Flow
```
HexGraph (runtime graph)
       ↓
VisualGraph::from_hex_graph() (transform to visual model)
       ↓
ExportGraph use case (orchestration)
       ↓
FormatExporter adapter (format-specific)
       ↓
String output (DOT/Mermaid/JSON)
```

### Query Flow
```
User calls graph.query()
       ↓
GraphQuery builder (fluent API)
       ↓
.layer()/.role() filters applied
       ↓
.execute() runs filters
       ↓
Vec<&HexNode> returned
```

## Design Patterns Used

### 1. Port/Adapter (Throughout)
Every layer follows port/adapter separation.

### 2. Builder Pattern
- `GraphBuilder` - Fluent graph construction
- `GraphQuery` - Fluent querying
- `HexError` - Error construction with methods

### 3. Strategy Pattern
- `FormatExporter` - Different export strategies
- `LayoutEngine` - Different layout algorithms

### 4. Registry Pattern
- `ComponentRegistry` - Global component registry
- `inventory` integration - Compile-time collection

### 5. Visitor Pattern (Implicit)
- Graph analysis algorithms traverse nodes
- Intent inference examines structure

### 6. Facade Pattern
- `HexGraph::to_dot()` - Simple interface over complex system
- Convenience methods hide use case orchestration

## Thread Safety

### Immutable Graph (Phase 2)
- `HexGraph` wraps `Arc<HexGraphInner>`
- All operations return new snapshots
- No locks needed for reads (common case)

### Registry
- `inventory` crate handles thread-safe collection
- Registry build happens once, then immutable

## Performance Characteristics

| Operation | Complexity | Notes |
|-----------|------------|-------|
| Add node (build) | O(1) | Via HashMap |
| Query by layer | O(n) | Linear scan |
| Query by role | O(n) | Linear scan |
| Find node by ID | O(1) | HashMap lookup |
| Edges from node | O(m) | m = edge count |
| Cycle detection | O(V+E) | DFS-based |
| Export to format | O(V+E) | Visit all nodes/edges |

## Testing Strategy

### Unit Tests
- In-file tests for each module
- Test pure functions in isolation

### Integration Tests
- `tests/integration_test.rs` - End-to-end scenarios
- Test macro-generated code
- Test graph construction from registry

### Example Tests
- Examples double as integration tests
- Verified by `cargo test --examples`

## Future Architecture Considerations

### Phase 6+
- Incremental graph updates
- Graph diffing for version comparison
- Persistent graph storage (hexagonal!)
- Advanced layout algorithms
- Performance optimizations for large graphs

### Extensibility Points
- New formatters: Implement `FormatExporter`
- New layout engines: Implement `LayoutEngine`
- New analysis: Add methods to `GraphAnalysis`
- New validation: Add methods to `ArchitecturalValidator`

## Contributing to Architecture

When adding new features:

1. **Identify the layer** - Domain, Port, Adapter, Application?
2. **Follow dependency rules** - Dependencies point inward
3. **One item per file** - Maintain modularity
4. **Document decisions** - Add to ADRs if architectural
5. **Test thoroughly** - Unit + integration tests

## Key Architectural Decisions

See `docs/adr/` for detailed Architecture Decision Records:

- ADR 0001: Hexagonal Architecture Choice
- ADR 0002: One Item Per File Standard
- ADR 0003: No Imports, Fully Qualified Paths
- ADR 0004: Compile-Time Registration via Inventory
- ADR 0005: Immutable Graph with Arc
- ADR 0006: Visualization Ports and Adapters

---

**Version:** 0.3.0
**Last Updated:** 2025-10-02
**Maintained By:** hex team
```
</llm-patch>

Due to response length limits, I'll continue with the next critical documentation file in my next response. Let me know if you'd like me to continue with:
- ADR template
- Examples README
- COOKBOOK.md
- Or prioritize a different document?

kotlin.Unit

==== UserMessageImpl #34 ====
User:
continue
Attachments:
Attachment Name: SYS_PROMPT.md
Attachments Kind: Visible
Attachments Source: AiRuleContextSource / ChatAttachmentWithFilePathWrapper
Attachments Text:
````markdown
---
apply: always
---

## AI Assistant: Add Revision History when altering a file
**YOU WILL NEVER ALTER THIS SYS_PROMPT FILE.**

Whenever you alter a file, add a revision history comment at the END of the documentation pre-amble and BEFORE any scripting. It MUST be in a valid Rust location. This should include:
- The date and time of the change in UTC.
- The user or AI that made the change.
- A brief formal description of the change.
```rust
//! Revision History
//! - 2025-04-13T13:37:01Z @AI: Refine example comments per latest request.
//! - 2025-04-13T13:35:39Z @AI: Clean example comments, add note on test doc simplicity.
//! - 2025-04-13T13:28:27Z @AI: Clean examples (remove comments), promote functional style in example and guidelines.
//! - 2025-04-13T13:24:57Z @AI: Ensure all example comments are doc comments, add example revision history.
//! - 2025-04-13T13:23:12Z @Gemini25: Update guidelines: Add revision history, restrict traits/generics, convert example comments.
```

---
## Target
**N Lang** (short for “N Language,” or simply “n”) is a modern, typed, *declarative* programming language & system for writing **node programs**. Sometimes characterized as "Rust for the rest of us".

---
## Overall Goals
Create code that uses the "Language of the language" of Rust to achieve the following goals: Maintainability, Reliability, Security, and Speed.

-  **Maintainability**: is achieved through clarity, simplicity, and modularity.
-  **Reliability**: is ensured by adhering to the Single Responsibility Principle and avoiding unnecessary complexity.
-  **Security**: is prioritized by avoiding unsafe code and ensuring proper error handling. The one exception to this is FFI.
-  **Speed**: Speed is applied to Maintainability, Reliability, Security, and Performance.
  -  **Maintainability Speed**: is achieved by thinking like a librarian.
  -  **Reliability Speed**: is achieved by thinking like an engineer.
  -  **Security**: speed is achieved by thinking like a hacker.
  -  **Performance**: speed is achieved through efficient algorithms and data structures.

---

## Conventions
Words that appear in ALL CAPS are hard requirements. Words that appear in **bold** are strong recommendations. Words that appear in *italics* are suggestions.

In a mulit-crate project, maintaining README.md's for each crate is critcal for project success. README.md files should contain a knowledge graph of their contents.

---

## Rust Architecture Standards: Hexagonal Architecture
These standards articulate the Single Responsibility Principle.
Each unit of a program, from modules to functions to structs, should have at most one responsibility and follow Domain, Ports, Adapters, Application, and Infrastructure (DPAI) architecture.

Example:

| Layer                  | Role                                                   | Example Code Components                                                 |
|------------------------|--------------------------------------------------------|-------------------------------------------------------------------------|
| **Core Domain**        | Business logic, no framework or tech dependency        | `Parser`, `Grammar`, `WriteAheadLog`, `ForeignFunctions` traits for I/O |
| **Ports (Interfaces)** | Interfaces to the outside world                        | Traits like `SnappRepository`, `WebPort`                                |
| **Adapters**           | Implementations of the ports for specific technologies | e.g., `SqlLiteRepo`, `ActixWebPort`, REST API                           |
| **Application Layer**  | Coordinates between domain and ports                   | `NCLI`, `NAPI`, command handlers                                        |
| **Infrastructure**     | Databases, APIs, etc.                                  | Uses `axum`, `sqlx`, `tokio`                                            |

---

## Rust Coding Standards: One Item Per File

These standards promote extreme modularity and clarity of origin by enforcing a strict "one item per file" structure and mandating the USE OF fully qualified paths (except where built into `std` or in tests where `super` can be used, e.g. `std::result::Result` MUST BE `Result`, `std::string::String` MUST BE `String`, etc...).

**Safety First: NEVER use `unsafe`, and use Rust 2024+ edition**

**Brevity: NEVER use two words when 1 will do, avoid colorful language, avoid emojis unless asked**

**1. Granularity: One Logical Item Per File**

*   **Rule:** Each `.rs` file must contain exactly one primary logical Rust item.
*   **Definition of "Item":** This typically refers to a single `fn`, `struct`, `enum`, `type` alias, or constant (`const`/`static`). Traits and generic items are generally discouraged unless they are used for grouping functions categorically or strictly required for interaction with external library APIs.
  *   Associated `impl` blocks for a `struct` or `enum` defined in `my_item.rs` should also reside within `my_item.rs`.
  *   `impl Trait for Type` blocks might reside with `Type`'s definition if `Type` is local, or potentially in their own file (e.g., `my_type_impl_some_trait.rs`) if the implementation itself is complex or significant, especially when implementing external traits for local types or vice-versa. For simplicity, start by keeping implementations with the type definition.
*   **File Naming:** Files should be named using `snake_case.rs`, matching the name of the item they contain (e.g., `my_function.rs` for `fn my_function`, `my_struct.rs` for `struct MyStruct`).
*   **Modules:** Module files (`mod.rs` or `directory/mod.rs`) are exceptions as their purpose is to declare and organize sub-modules or re-export items. However, they should generally not contain item definitions themselves, only `mod` statements.

**2. File Preamble Documentation**

*   **Rule:** Every `.rs` file *MUST* begin with file-level documentation comments (`//!`).
*   **Structure:**
  *   The very first line must be a single, concise sentence summarizing the purpose or content of the file (the item it defines).
  *   Follow this immediately with a blank documentation line (`//!`).
  *   Provide 3-5 additional lines (`//!`) expanding on the summary, detailing purpose, context, high-level usage, or important considerations.
*   **Rule:** Item's MUST use documentation comments (`///`) and prefer documentation testing.
*   **Structure:**
  *   ```rust
      /// Adds two integers together
      fn add(l: i8, r: i8) -> i8 { l + r }
      ```

**3. Traits as Maps of Content and Function Categories**
*   **Rule:** `trait` blocks with function defaults are forbidden, with no exceptions.
*   **Usage:** Traits are used to categorize groups of functions. Traits should be used as Zettelkasten Maps Of Content providing function categories.
  *   Example: A trait `MyTrait` might define functions like `fn category_function_name(&self) -> Result<(), String>;` without providing a default implementation.

* **4. No Imports: Use Fully Qualified Paths**

*   **Rule:** `use` statements are forbidden, with no exceptions.
*   **Usage:** All types, functions, macros, traits, etc., from the standard library, external crates, or other modules within the current crate must be referred to by their fully qualified path.
  *   Example (Standard Library): `std::collections::HashMap`, `std::vec::Vec`, `std::string::String`, `std::println!`
  *   But things that are available without imports are ok without FQN: `Vec`, `String`, `println!`, `Option` etc
  *   Example (External Crate `serde`): `serde::Serialize`, `serde_json::to_string`
  *   Example (Internal Crate): `crate::Mymod::MyStruct`, `crate::utils::helper_function`
*   **Rationale:** This makes the origin of every identifier immediately explicit, reducing ambiguity, although it increases verbosity.

**Functional Style Encouraged**

*   **Guideline:** While adhering to the rules above, favor a functional programming style where appropriate.
*   **Rationale:** Aligns with the broader framework's emphasis on pure functions and data transformations (as outlined in the main `CODING_STANDARDS.md`). Prefer immutable data, pure functions, and iterator-based transformations (`map`, `filter`, `fold`, `sum`, etc.) over imperative loops and mutable state when it enhances clarity and maintains conciseness.
*   **Example:** The example function `calculate_weighted_sum` demonstrates using iterators (`zip`, `map`, `sum`) for calculation.

---

**5. Function Length Limit**

*   **Rule:** Functions should not exceed 50 lines of code (LoC).
*   **Measurement:** This count includes lines within the function body `{ ... }`, excluding the function signature, comments, and blank lines.
*   **Goal:** Encourage breaking down complex logic into smaller, more focused, testable, and reusable functions. Promotes the Single Responsibility Principle at the function level.
*   **Exceptions:** Permitted rarely and must be justified. Examples include:
  *   Large but simple `match` statements that are inherently sequential and difficult to split meaningfully.
  *   Boilerplate code generated by macros (though the generated code might exceed the limit, the source code shouldn't).
  *   Functions primarily consisting of data structure literals.
  *   *When making an exception, add a comment explaining why the function length is justified.*

**6. In-File Tests for Functions**

*   **Rule:** Unit tests for a function must reside within the same file as the function definition.
*   **Structure:** Use the standard `#[cfg(test)]` attribute on a private inner module (conventionally named `tests`).
  *   ```rust
    // ... function definition ...

    #[cfg(test)]
    mod tests {
    // Use super::* to access the item in the parent module (the file scope)
    // Note: Even with super::*, accessing OTHER items still requires full paths.
    // For the function under test:
    // use super::my_function_name; // This would be disallowed by Rule 3 if strictly applied
    // Instead, call it via super::my_function_name directly.

          #[test]
          fn test_case_1() {
              let result = super::my_function_name( /* args */ );
              std::assert_eq!(result, expected_value);
              // Note: assert_eq! is often in the prelude, but strictly might require std::assert_eq!
          }
          // ... more tests ...
    }
      ```
*   **Scope:** Tests should focus on validating the behavior of the function defined in the file, covering success cases, edge cases, and error conditions.

---

## Example Ideal File: `calculate_weighted_sum.rs`

```rust
//! Calculates the weighted sum of a slice of numbers using provided weights.
//!
//! This function takes two slices: one for values and one for their corresponding weights.
//! It computes the sum of `value * weight` for each pair.
//! Returns an error if slices differ in length or are empty.
//! Ensures inputs are valid before calculation.

//! Revision History
//! - 2025-04-13T13:37:01Z @AI: Refined internal comments per latest request.
//! - 2025-04-13T13:24:57Z @AI: Convert all example comments to doc comments, add example revision history.

/// Calculates Weighted Sum
pub fn calculate_weighted_sum(values: &[f64], weights: &[f64]) -> Result<f64, String> {
  // Validate input lengths.
  if values.len() != weights.len() {
    return std::result::Result::Err(String::from(
        "Value and weight slices must have the same length.",
    ));
  }
  // Handle empty slices case. Weighted sum of empty is 0.0.
  if values.is_empty() {
    return std::result::Result::Ok(0.0);
  }

  // Calculate using functional style: zip values and weights, map to product, sum results.
  let weighted_sum: f64 = values
      .iter()
      .zip(weights.iter())
      .map(|(v, w)| v * w)
      .sum();

  std::result::Result::Ok(weighted_sum)
}

#[cfg(test)]
mod tests {
    // Access the function under test via `super::`. Full paths for other items.
    // Test documentation is concise per guidelines.
    #[test]
    fn test_basic_weighted_sum() {
        // Test with standard positive values.
        let values = [1.0, 2.0, 3.0];
        let weights = [0.5, 1.0, 2.0];
        // Expected: (1.0*0.5) + (2.0*1.0) + (3.0*2.0) = 0.5 + 2.0 + 6.0 = 8.5
        let result = super::calculate_weighted_sum(&values, &weights);
        // Note: Using std::assert_eq! directly for simplicity. Float comparison might need tolerance.
        assert_eq!(result, Result::Ok(8.5));
    }

    #[test]
    fn test_empty_slices() {
        // Test the defined behavior for empty input slices.
        let values: [f64; 0] = [];
        let weights: [f64; 0] = [];
        let result = super::calculate_weighted_sum(&values, &weights);
        // Expected: Ok(0.0) based on implementation choice.
        assert_eq!(result, Result::Ok(0.0));
    }

    #[test]
    fn test_mismatched_lengths() {
        // Test error handling for slices of different lengths.
        let values = [1.0, 2.0];
        let weights = [0.5];
        let result = super::calculate_weighted_sum(&values, &weights);
        assert!(result.is_err());
        // Check the specific error message.
        assert_eq!(
            result.unwrap_err(),
            String::from("Value and weight slices must have the same length.")
        );
    }

    #[test]
    fn test_negative_values_and_weights() {
        // Test calculation with negative numbers.
        let values = [-1.0, 2.0];
        let weights = [3.0, -0.5];
        // Expected: (-1.0 * 3.0) + (2.0 * -0.5) = -3.0 + -1.0 = -4.0
        let result = super::calculate_weighted_sum(&values, &weights);
        assert_eq!(result, Result::Ok(-4.0));
    }
}
```

This example adheres to all the specified rules:
1.  **One Item:** The file `calculate_weighted_sum.rs` contains only the function `calculate_weighted_sum`.
2.  **Preamble:** It starts with `//!` documentation, including a one-sentence summary and further lines of explanation.
4.  **Function Length:** The function body is short, well under 50 lines.
5.  **In-File Tests:** Tests are included in the same file under `#[cfg(test)] mod tests { ... }`, using `super::calculate_weighted_sum` to access the function.

IMPORTANT:
- **Application, Not Inclusion:** These guidelines describe *how* to write code. Do not copy the text of these guidelines into your Rust source files. Apply the principles described here.
- struct fields can be public

ALWAYS IMPLEMENT THINGS FULLY

---
## Revision History
- 2025-08-04T13:23:12Z @scott: Update guidelines: Add revision history, restrict traits/generics, convert example comments, add hexagonal architecture, maps of content explanation.

````
Attachment Name: ERRORS_PROMPT.md
Attachments Kind: Visible
Attachments Source: AiRuleContextSource / ChatAttachmentWithFilePathWrapper
Attachments Text:
````markdown
---
apply: always
---

# ERRORS_PROMPT: N Lang Error Handling Guidelines for AI Assistance
This file extends SYS_PROMPT.md with specific guidelines for handling errors in N Lang.

## Purpose
All errors encountered within this module should be treated as prompts for an AI agent to generate a clear, actionable remedial action plan. The goal is to maximize accessibility and provide the best possible user experience.

Errors follow a specific format to ensure consistency and clarity. Each error message should be brief, empathetic, and provide actionable next steps and suggestions for the user as well as a way to obtain more information.

## Guidelines
1. **Errors MUST BE Remedial prompts**
  - Errors are designed for formal AI assistance and Users.

2. **Brief Empathetic Communication**
   - Acknowledge the user's situation, but avoid saying "You".
   - Avoid blame or technical jargon; focus on understanding and support.

3. **Accessibility**
   - Use plain, simple language that is easy to understand for all users.
   - Ensure error messages are compatible with screen readers and assistive technologies.

4. **Actionable Remediation**
   - Every error message must include a suggested next step or solution.
   - Where possible, provide examples or links to relevant documentation.

5. **Clarity and Brevity**
   - State the error clearly and concisely.
   - Avoid unnecessary details; focus on what the user needs to know and do.

6. **Consistency**
   - Maintain a uniform style and structure for all error prompts.
   - Use consistent terminology and formatting.

7. **Positive Tone**
   - Encourage and reassure users that errors are a normal part of the process.
   - Offer constructive guidance to help users resolve issues confidently.

## Example Error Prompt

CLI Error Example:
```
Error: Invalid project name. The project name contains unsupported characters.
Next Steps: Try again, using only letters, numbers, and underscores.
Suggestions: Projct_name, Project_Name, ProjectName_123
More: https://nlang.io/errors/E_VM_22
```

Compiler Error Example:
```
Error: Invalid type annotation. Type annotation 'Int' does not match the value '15u'.
Next Steps: Make changes and try again
  - Either:
    - Change the type annotation to match the value.
    - Change the value to match the type annotation.
    - Cast the value to the type annotation.
Suggestions:
  - Either:
    - `let x: Int = 15;`
    - `let x: Uint = 15u;`
    - `let x: Uint => Int = 15u;`
More: https://nlang.io/errors/E_CMP_0222

Sources:
/file/file_name.n.md:196:13

   196: let x: Int = 15u;
                     ^^^ Cannot assign explicitly set unsigned integer to atomic Int.
```


## Comparison to Rust's Error Handling

N Lang's error system, as currently implemented, draws significant inspiration from Rust's error handling philosophy, especially in terms of:

- **Structured, Rich Error Types:** Like Rust, N Lang uses enums and structs to encode error context, sources, and suggestions.
- **Colorful, Readable Output:** The use of ANSI color codes for error display mirrors Rust's CLI error output, improving accessibility and clarity.
- **Actionable Guidance:** Each error provides next steps, suggestions, and links for more information, going beyond Rust's default error messages by making remediation explicit and user-centric.
- **Source Tracking:** The inclusion of detailed source information (file, row, col, and error snippet) is similar to Rust's compiler diagnostics, supporting traceability and debugging.

### Key Differences

- **AI-First Remediation:** N Lang's errors are explicitly designed as prompts for AI agents to generate remedial action plans, with a strong focus on accessibility and empathy.
- **Hexagonal Architecture & Modularity:** The system enforces a stricter one-item-per-file and fully qualified path rule, promoting extreme modularity and clarity of origin.
- **Extensible Error Metadata:** Errors in N Lang are designed to be easily extended with additional context, suggestions, and links, supporting both human and AI consumers.

---

## Recommendations for Further Improvement

1. **Error Codes and Categorization**
  - Introduce a formal error code system (e.g., `E_CMP_001`) for all error variants, similar to Rust's compiler errors, to aid in documentation, searchability, and automated remediation.

2. **Localization and Internationalization**
  - Add support for localizing error messages, next steps, and suggestions to improve accessibility for non-English speakers.

3. **Rich Source Context**
  - Enhance source reporting to include code context (e.g., lines before/after the error), and consider integrating with editors for clickable diagnostics.

4. **Error Chaining and Causality**
  - Implement error chaining (e.g., `source()` methods) to allow errors to reference underlying causes, as in Rust's `std::error::Error`.

5. **Structured Machine-Readable Output**
  - Provide a way to serialize errors (e.g., to JSON or YAML) for integration with tools, editors, and AI agents.

6. **Consistent Error Construction APIs**
  - Consider builder patterns or macros for constructing complex errors, reducing boilerplate and improving ergonomics.

7. **Extensive Testing and Fuzzing**
  - Expand test coverage, including property-based and fuzz testing, to ensure robustness and catch edge cases.

8. **Documentation and Examples**
  - Continue to expand documentation and real-world usage examples, making it easier for contributors and users to understand and extend the error system.

---

## Next Steps

- Prioritize the introduction of error codes and error chaining.
- Begin designing a serialization format for errors.
- Review and refactor error construction APIs for consistency and ergonomics.
- Expand documentation with more real-world error scenarios and AI remediation examples.

---

## Revision History


## Revision History
- 2024-06-08T15:37:00Z @GitHub Copilot: Initial formal error handling prompt guidelines.


````
Attachment Name: Code around the caret in the current file:
Attachments Kind: Visible
Attachments Source: CodeAtCaretRetriever / ChatAttachmentWithFilePathWrapper
Attachments Text:
```rust
impl hex::domain::Entity for Todo {
    type Id = String;
}

// Adapter: In-memory repository
struct InMemoryTodoRepository {
    todos: Vec<Todo>,
}

impl InMemoryTodoRepository {
    fn new() -> Self {<CARET>
        Self {
            todos: Vec::new(),
        }
    }
}

impl hex::adapters::Adapter for InMemoryTodoRepository {}

impl hex::ports::Repository<Todo> for InMemoryTodoRepository {
```


kotlin.Unit

==== SimpleCompletableMessage #35 ====
Assistant:


kotlin.Unit

