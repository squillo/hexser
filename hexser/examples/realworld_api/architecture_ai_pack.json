{"schema_version":"1.0.0","crate_name":"hexser","crate_version":"0.4.5","ai_context":{"architecture":"hexagonal","version":"0.4.5","components":[{"type_name":"realworld_api::ports::comment_repository::CommentSortKey","layer":"Port","role":"Repository","module_path":"realworld_api::ports::comment_repository","purpose":null,"dependencies":[]},{"type_name":"realworld_api::ports::user_repository::UserFilter","layer":"Port","role":"Repository","module_path":"realworld_api::ports::user_repository","purpose":null,"dependencies":[]},{"type_name":"realworld_api::adapters::in_memory_db::tag_adapter::InMemoryTagRepository","layer":"Adapter","role":"Adapter","module_path":"realworld_api::adapters::in_memory_db::tag_adapter","purpose":null,"dependencies":[]},{"type_name":"realworld_api::domain::comment::Comment","layer":"Domain","role":"Entity","module_path":"realworld_api::domain::comment","purpose":null,"dependencies":[]},{"type_name":"realworld_api::adapters::in_memory_db::comment_adapter::InMemoryCommentRepository","layer":"Adapter","role":"Adapter","module_path":"realworld_api::adapters::in_memory_db::comment_adapter","purpose":null,"dependencies":[]},{"type_name":"realworld_api::adapters::in_memory_db::article_adapter::InMemoryArticleRepository","layer":"Adapter","role":"Adapter","module_path":"realworld_api::adapters::in_memory_db::article_adapter","purpose":null,"dependencies":[]},{"type_name":"realworld_api::ports::comment_repository::CommentFilter","layer":"Port","role":"Repository","module_path":"realworld_api::ports::comment_repository","purpose":null,"dependencies":[]},{"type_name":"realworld_api::ports::user_repository::UserSortKey","layer":"Port","role":"Repository","module_path":"realworld_api::ports::user_repository","purpose":null,"dependencies":[]},{"type_name":"realworld_api::ports::article_repository::ArticleFilter","layer":"Port","role":"Repository","module_path":"realworld_api::ports::article_repository","purpose":null,"dependencies":[]},{"type_name":"realworld_api::ports::article_repository::ArticleSortKey","layer":"Port","role":"Repository","module_path":"realworld_api::ports::article_repository","purpose":null,"dependencies":[]},{"type_name":"realworld_api::domain::user::User","layer":"Domain","role":"Entity","module_path":"realworld_api::domain::user","purpose":null,"dependencies":[]},{"type_name":"realworld_api::domain::tag::Tag","layer":"Domain","role":"Entity","module_path":"realworld_api::domain::tag","purpose":null,"dependencies":[]},{"type_name":"realworld_api::domain::article::Article","layer":"Domain","role":"Entity","module_path":"realworld_api::domain::article","purpose":null,"dependencies":[]},{"type_name":"realworld_api::adapters::in_memory_db::user_adapter::InMemoryUserRepository","layer":"Adapter","role":"Adapter","module_path":"realworld_api::adapters::in_memory_db::user_adapter","purpose":null,"dependencies":[]}],"relationships":[],"constraints":{"dependency_rules":[{"from_layer":"Domain","to_layer":"Infrastructure","allowed":false,"reason":"Domain must not depend on infrastructure"},{"from_layer":"Application","to_layer":"Domain","allowed":true,"reason":"Application coordinates domain logic"}],"layer_boundaries":[{"layer":"Domain","can_depend_on":[],"dependents_allowed":["Ports","Application"],"purpose":"Pure business logic with zero dependencies"},{"layer":"Ports","can_depend_on":["Domain"],"dependents_allowed":["Adapters","Application"],"purpose":"Interfaces defining what application needs"}],"naming_conventions":[{"applies_to":"Repository ports","pattern":"*Repository trait","example":"trait UserRepository: Repository<User>"},{"applies_to":"Directives","pattern":"*Directive struct","example":"struct CreateUserDirective"}],"required_patterns":["One item per file","No use statements","Fully qualified paths"]},"suggestions":[{"suggestion_type":"missing_implementation","component":null,"description":"More ports than adapters - some ports may need implementations","priority":"medium","code_example":null}],"metadata":{"generated_at":"2025-10-10T19:40:07.211515+00:00","hex_version":"0.4.5","total_components":14,"total_relationships":0,"schema_version":"1.0.0"}},"guidelines":{"unsafe_forbidden":true,"use_statements_forbidden":true,"function_length_max":50,"testing_mandate":true,"error_guidelines":["C-QUESTION-MARK","C-GOOD-ERR","C-CTOR","C-STRUCT-PRIVATE"],"revision_history_required":true},"docs":{"entries":[{"path":"/Users/scott/@squillo/n-rust/nlang_hex/hexser/README.md","title":"# Hexser - Zero-Boilerplate Hexagonal Architecture","content":"# Hexser - Zero-Boilerplate Hexagonal Architecture\n\n[![Crates.io](https://img.shields.io/crates/v/hexser.svg)](https://crates.io/crates/hexser)\n[![Documentation](https://docs.rs/hexser/badge.svg)](https://docs.rs/hexser)\n[![License](https://img.shields.io/crates/l/hexser.svg)](https://github.com/squillo/hexser)\n\n**Zero-boilerplate hexagonal architecture with graph-based introspection for Rust.**\n\nThe `hexser` crate provides reusable generic types and traits for implementing Hexagonal Architecture (Ports and Adapters pattern) with automatic graph construction, intent inference, and architectural validation. **Write business logic, let `hexser` handle the architecture.**\n\n---\n\n## Table of Contents\n\n- [Why hexser?](#why-hexser)\n- [Quick Start](#quick-start)\n- [Feature Flags](#feature-flags)\n- [Complete Tutorial](#complete-tutorial)\n- [CQRS Pattern with hex](#part-3-cqrs-pattern-with-hex)\n- [Testing Your Hexagonal Application](#part-4-testing-your-hexagonal-application)\n- [Error Handling](#part-5-error-handling)\n- [Real-World Example - TODO Application](#part-6-real-world-example---todo-application)\n- [Advanced Patterns](#advanced-patterns)\n- [Knowledge Graph](#knowledge-graph)\n- [Static (non-dyn) DI — WASM-friendly](#static-non-dyn-di--wasm-friendly)\n- [Repository: Filter-based queries (vNext)](#repository-filter-based-queries-vnext)\n- [AI Context Export (CLI)](#ai-context-export-cli)\n- [MCP Server (Model Context Protocol)](#-mcp-server-model-context-protocol)\n- [Examples & Tutorials](#examples--tutorials)\n- [Potions (copy-friendly examples)](#potions-copy-friendly-examples)\n- [Contributing](#contributing)\n- [License](#license)\n- [Acknowledgments](#acknowledgments)\n- [Additional Resources](#additional-resources)\n\n> Tip: Press Cmd/Ctrl+F and search for “Part” to jump to tutorials.\n\n## Why hexser?\n\nTraditional hexagonal architecture requires significant boilerplate:\n- Manual registration of components\n- Explicit dependency wiring\n- Repetitive trait implementations\n- Complex validation logic\n\n**hexser eliminates all of this.** Through intelligent trait design, compile-time graph construction, and rich error handling, you get:\n\n- [x] **Zero Boilerplate** - Define your types, derive traits, done\n- [x] **Type-Safe Architecture** - Compiler enforces layer boundaries\n- [x] **Self-Documenting** - Graph visualization shows your architecture\n- [x] **Intent Inference** - System understands itself through structure\n- [x] **Rich Errors** - Helpful, actionable error messages\n- [x] **Zero Runtime Overhead** - Everything happens at compile time\n- [x] **AI Completion** - Expose your Rust architecture to AI agents\n\n---\n\n## Quick Start\n\nAdd to your `Cargo.toml`:\n\n```toml\n[dependencies]\nhexser = \"0.4.5\"\n```\n\nYour First Hexagonal Application\n\n```rust\nuse hexser::prelude::*;\n\n// 1. Define your domain entity\n#[derive(Entity)]\nstruct User {\n  id: String,\n  email: String,\n  name: String,\n}\n\n// 2. Define a port (interface)\n#[derive(HexPort)]\ntrait UserRepository: Repository<User> {\n  fn find_by_email(&self, email: &str) -> HexResult<Option<User>>;\n}\n\n// 3. Implement an adapter\n#[derive(HexAdapter)]\nstruct InMemoryUserRepository {\n    users: Vec<User>,\n}\n\nimpl Repository<User> for InMemoryUserRepository {\n  fn save(&mut self, user: User) -> HexResult<()> {\n    if let Some(existing) = self.users.iter_mut().find(|u| u.id == user.id) {\n      *existing = user;\n    } else {\n      self.users.push(user);\n    }\n    Ok(())\n  }\n}\n\nimpl UserRepository for InMemoryUserRepository {\n  fn find_by_email(&self, email: &str) -> HexResult<Option<User>> {\n    Ok(self.users.iter().find(|u| u.email == email).cloned())\n  }\n}\n\n// 4. Use it!\nfn main() -> HexResult<()> {\n    let mut repo = InMemoryUserRepository { users: Vec::new() };\n\n    let user = User {\n      id: \"1\".to_string(),\n      email: \"alice@example.com\".to_string(),\n      name: \"Alice\".to_string(),\n    };\n\n    repo.save(user)?;\n\n    let found = repo.find_by_email(\"alice@example.com\")?;\n    println!(\"Found: {:?}\", found.map(|u| u.name));\n\n    Ok(())\n}\n```\n\nThat's it! You've just built a hexagonal architecture application with:\n- Clear layer separation\n- Type-safe interfaces\n- Testable components\n- Swappable implementations\n\n---\n\n## Feature Flags\n\nHexser provides granular feature flags to enable only the functionality you need. This keeps compile times fast and binary sizes small, especially for WASM targets.\n\n### Available Features\n\n#### `default = [\"macros\", \"static-di\"]`\nEnabled by default. Includes procedural macros and zero-cost static dependency injection.\n\n```toml\n[dependencies]\nhexser = \"0.4.5\"  # Uses default features\n```\n\n#### `macros`\nEnables procedural macros for deriving hexagonal architecture traits.\n\n**Provides:**\n- `#[derive(HexEntity)]` - Implement HexEntity trait for domain entities\n- `#[derive(HexValueItem)]` - Implement HexValueItem trait with default validation (override validate() for custom logic)\n- `#[derive(HexAggregate)]` - Mark aggregate roots\n- `#[derive(HexPort)]` - Mark port traits\n- `#[derive(HexAdapter)]` - Mark adapter implementations\n- `#[derive(HexRepository)]` - Mark repository ports\n- `#[derive(HexDirective)]` - Mark command/directive types\n- `#[derive(HexQuery)]` - Mark query types\n\n**Dependencies:** `hexser_macros`\n\n```toml\n[dependencies]\nhexser = { version = \"0.4.5\", default-features = false, features = [\"macros\"] }\n```\n\n#### `static-di`\nZero-cost, WASM-friendly static dependency injection. No runtime overhead, no dynamic dispatch.\n\n**Provides:**\n- `StaticContainer` for compile-time dependency resolution\n- Type-safe service registration without `dyn`\n- Full WASM compatibility\n\n**Dependencies:** None (zero-cost abstraction)\n\n```toml\n[dependencies]\nhexser = { version = \"0.4.5\", features = [\"static-di\"] }\n```\n\n**Example:**\n```rust\nuse hexser::prelude::*;\n\nlet container = StaticContainer::new()\n    .with_service(MyRepository::new())\n    .with_service(MyService::new());\n\nlet service = container.get::<MyService>();\n```\n\n#### `ai`\nEnables AI context export functionality for exposing architecture metadata to AI agents.\n\n**Provides:**\n- `AIContext` type with architecture metadata\n- `AgentPack` for packaging context\n- JSON serialization of graph data\n- CLI tools: `hex-ai-export`, `hex-ai-pack`\n\n**Dependencies:** `chrono`, `serde`, `serde_json`\n\n```toml\n[dependencies]\nhexser = { version = \"0.4.5\", features = [\"ai\"] }\n```\n\n**Usage:**\n```bash\n# Export architecture context to JSON\ncargo run --bin hex-ai-export > context.json\n\n# Create agent pack\ncargo run --bin hex-ai-pack --output agent-pack.json\n```\n\n#### `mcp`\nModel Context Protocol server implementation for serving architecture data via JSON-RPC.\n\n**Provides:**\n- MCP server over stdio transport\n- Resources: `hexser://context`, `hexser://pack`\n- JSON-RPC 2.0 interface\n- CLI tool: `hex-mcp-server`\n\n**Dependencies:** Requires `ai` feature, plus `serde`, `serde_json`\n\n```toml\n[dependencies]\nhexser = { version = \"0.4.5\", features = [\"mcp\"] }\n```\n\n**Usage:**\n```bash\n# Start MCP server (communicates via stdin/stdout)\ncargo run --bin hex-mcp-server\n```\n\n#### `async`\nEnables async/await support for ports and adapters.\n\n**Provides:**\n- `AsyncRepository` trait\n- `AsyncDirective` trait\n- `AsyncQuery` trait\n- Tokio runtime integration\n\n**Dependencies:** `tokio`, `async-trait`\n\n```toml\n[dependencies]\nhexser = { version = \"0.4.5\", features = [\"async\"] }\n```\n\n**Example:**\n```rust\n#[async_trait::async_trait]\nimpl AsyncRepository<User> for AsyncUserRepo {\n    async fn find_by_id(&self, id: &String) -> HexResult<Option<User>> {\n        // async implementation\n    }\n}\n```\n\n#### `visualization`\nEnables graph visualization and export capabilities.\n\n**Provides:**\n- Graph serialization to JSON\n- DOT format export for Graphviz\n- Architecture diagram generation\n\n**Dependencies:** `serde`, `serde_json`\n\n```toml\n[dependencies]\nhexser = { version = \"0.4.5\", features = [\"visualization\"] }\n```\n\n#### `container`\nDynamic dependency injection container with async support. **Not enabled by default** to maintain WASM compatibility.\n\n**Provides:**\n- `DynContainer` with runtime service resolution\n- Async service factories\n- Dynamic dispatch with `dyn` traits\n\n**Dependencies:** `tokio`, `async-trait`\n\n**Note:** Use `static-di` instead if you need WASM compatibility or want zero runtime overhead.\n\n```toml\n[dependencies]\nhexser = { version = \"0.4.5\", features = [\"container\"] }\n```\n\n#### `full`\nEnables all features: `ai`, `mcp`, `async`, `macros`, `visualization`, `container`, and `static-di`.\n\n**Use for:** Development, full-featured applications, or when you need all capabilities.\n\n```toml\n[dependencies]\nhexser = { version = \"0.4.5\", features = [\"full\"] }\n```\n\n### Binary Targets\n\nHexser includes three command-line tools that require specific features:\n\n#### `hex-ai-export`\nExports architecture context as JSON for AI consumption.\n\n**Required feature:** `ai`\n\n```bash\ncargo run --bin hex-ai-export --features ai > context.json\n```\n\n#### `hex-ai-pack`\nCreates a complete agent pack with architecture metadata.\n\n**Required feature:** `ai`\n\n```bash\ncargo run --bin hex-ai-pack --features ai --output pack.json\n```\n\n#### `hex-mcp-server`\nRuns an MCP (Model Context Protocol) server over stdio.\n\n**Required feature:** `mcp`\n\n```bash\ncargo run --bin hex-mcp-server --features mcp\n```\n\n### Feature Combinations\n\n#### Minimal (no default features)\n```toml\n[dependencies]\nhexser = { version = \"0.4.5\", default-features = false }\n```\n\n#### WASM-optimized\n```toml\n[dependencies]\nhexser = { version = \"0.4.5\", default-features = false, features = [\"macros\", \"static-di\"] }\n```\n\n#### AI-enabled with async\n```toml\n[dependencies]\nhexser = { version = \"0.4.5\", features = [\"ai\", \"async\", \"visualization\"] }\n```\n\n#### Full development setup\n```toml\n[dependencies]\nhexser = { version = \"0.4.5\", features = [\"full\"] }\n```\n\n---\n\n## Complete Tutorial\n### Part 1: Understanding Hexagonal Architecture\nHexagonal Architecture (also known as Ports and Adapters) structures applications into concentric layers:\n\n```\n┌─────────────────────────────────────────────┐\n│         Infrastructure Layer                │\n│  (Databases, APIs, External Services)       │\n│                                             │\n│  ┌───────────────────────────────────────┐  │\n│  │      Adapters Layer                   │  │\n│  │  (Concrete Implementations)           │  │\n│  │                                       │  │\n│  │  ┌─────────────────────────────────┐  │  │\n│  │  │    Ports Layer                  │  │  │\n│  │  │  (Interfaces/Contracts)         │  │  │\n│  │  │                                 │  │  │\n│  │  │  ┌───────────────────────────┐  │  │  │\n│  │  │  │   Domain Layer            │  │  │  │\n│  │  │  │ (Business Logic)          │  │  │  │\n│  │  │  └───────────────────────────┘  │  │  │\n│  │  └─────────────────────────────────┘  │  │\n│  └───────────────────────────────────────┘  │\n└─────────────────────────────────────────────┘\n```\n\n**Key Principles:**\n- Dependency Rule: Dependencies point inward (Domain has no dependencies)\n- Port Interfaces: Define what the domain needs (don't dictate how)\n- Adapter Implementations: Provide concrete implementations using specific tech\n- Testability: Mock adapters for testing without infrastructure\n\n\n### Part 2: The Five Layers\n\n1. Domain Layer - Your Business Logic\nThe domain layer contains your core business logic, completely independent of frameworks or infrastructure.\nEntities - Things with identity:\n\n```rust\nuse hexser::prelude::*;\n\n#[derive(Entity)]\nstruct Order {\n  id: OrderId,\n  customer_id: CustomerId,\n  items: Vec<OrderItem>,\n  status: OrderStatus,\n}\n\nimpl Aggregate for Order {\n  fn check_invariants(&self) -> HexResult<()> {\n    if self.items.is_empty() {\n      return Err(hexser::hex_domain_error!(\n        hexser::error::codes::domain::INVARIANT_EMPTY,\n        \"Order must contain at least one item\"\n      ).with_next_step(\"Add at least one item\"));\n    }\n    Ok(())\n  }\n}\n```\n\nValue Objects - Things defined by values:\n\n```rust\n#[derive(Clone, PartialEq, Eq)]\nstruct Email(String);\n\nimpl HexValueItem for Email {\n  fn validate(&self) -> HexResult<()> {\n    if !self.0.contains('@') {\n      return Err(Hexserror::validation(\"Email must contain @\"));\n    }\n    Ok(())\n  }\n}\n```\n\nDomain Events - Things that happened:\n\n```rust\nstruct OrderPlaced {\n  order_id: OrderId,\n  customer_id: CustomerId,\n  timestamp: u64,\n}\n\nimpl DomainEvent for OrderPlaced {\n  // Manual implementation - no derive macro available\n}\n```\n\nDomain Services - Operations spanning multiple entities:\n```rust\nstruct PricingService;\n\nimpl DomainService for PricingService {\n  // Manual implementation - no derive macro available\n}\n\nimpl PricingService {\n  fn calculate_order_total(&self, order: &Order) -> Money {\n    order.items\n      .iter()\n      .map(|item| item.price * item.quantity)\n      .sum()\n  }\n}\n```\n\n\n2. Ports Layer - Your Interfaces\nPorts define the contracts between your domain and the outside world.\nRepositories - Persistence abstraction:\n\n```rust\n#[derive(HexPort)]\ntrait OrderRepository: Repository<Order> {\n  fn find_by_customer(&self, customer_id: &CustomerId)\n      -> HexResult<Vec<Order>>;\n\n  fn find_pending(&self) -> HexResult<Vec<Order>>;\n}\n```\n\nUse Cases - Business operations:\n\n```rust\n#[derive(HexPort)]\ntrait PlaceOrder: UseCase<PlaceOrderInput, PlaceOrderOutput> {}\n\nstruct PlaceOrderInput {\n  customer_id: CustomerId,\n  items: Vec<OrderItem>,\n}\n\nstruct PlaceOrderOutput {\n  order_id: OrderId,\n}\n```\n\nQueries - Read operations (CQRS):\n\n```rust\n#[derive(HexPort)]\ntrait OrderHistory: Query<OrderHistoryParams, Vec<OrderView>> {}\n\nstruct OrderHistoryParams {\n  customer_id: CustomerId,\n  from_date: u64,\n  to_date: u64,\n}\n\nstruct OrderView {\n  order_id: String,\n  total: f64,\n  status: String,\n}\n```\n\n\n3. Adapters Layer - Your Implementations\n   Adapters implement ports using specific technologies.\n\nDatabase Adapter:\n\n```rust\n#[derive(HexAdapter)]\nstruct PostgresOrderRepository {\n  pool: PgPool,\n}\n\nimpl Repository<Order> for PostgresOrderRepository {\n  fn save(&mut self, order: Order) -> HexResult<()> {\n      // SQL insert/update implementation\n      todo!()\n  }\n}\n\nimpl OrderRepository for PostgresOrderRepository {\n  fn find_by_customer(&self, customer_id: &CustomerId)\n  -> HexResult<Vec<Order>> {\n    // Custom query implementation\n    todo!()\n  }\n\n  fn find_pending(&self) -> HexResult<Vec<Order>> {\n      // Custom query implementation\n      todo!()\n  }\n}\n```\n\nAPI Adapter:\n\n```rust\n#[derive(HexAdapter)]\nstruct RestPaymentGateway {\n  client: reqwest::Client,\n  api_key: String,\n}\n\nimpl PaymentPort for RestPaymentGateway {\n  fn charge(&self, amount: Money, card: &Card) -> HexResult<PaymentResult> {\n    // HTTP API call implementation\n    todo!()\n  }\n}\n```\n\nMapper - Data transformation:\n\n```rust\n#[derive(HexAdapter)]\nstruct OrderMapper;\n\nimpl Mapper<Order, DbOrderRow> for OrderMapper {\n  fn map(&self, order: Order) -> HexResult<DbOrderRow> {\n    Ok(DbOrderRow {\n      id: order.id.to_string(),\n      customer_id: order.customer_id.to_string(),\n      items_json: serde_json::to_string(&order.items)?,\n      status: order.status.to_string(),\n    })\n  }\n}\n```\n\n\n4. Application Layer - Your Orchestration\nThe application layer coordinates domain logic and ports.\nDirective (Write Operation):\n\n```rust\n#[derive(HexDirective)]\nstruct PlaceOrderDirective {\n    customer_id: CustomerId,\n    items: Vec<OrderItem>,\n}\n\nimpl PlaceOrderDirective {\n  fn validate(&self) -> HexResult<()> {\n    if self.items.is_empty() {\n      return Err(Hexserror::validation(\"Items cannot be empty\"));\n    }\n    Ok(())\n  }\n}\n```\n\nDirective Handler:\n```rust\n#[derive(HexDirectiveHandler)]\nstruct PlaceOrderHandler {\n  order_repo: Box<dyn OrderRepository>,\n  payment_port: Box<dyn PaymentPort>,\n}\n\nimpl PlaceOrderHandler {\n  fn handle(&self, directive: PlaceOrderDirective) -> HexResult<()> {\n    // Validate\n    directive.validate()?;\n\n    // Create domain object\n    let order = Order::new(directive.customer_id, directive.items)?;\n\n    // Check invariants\n    order.check_invariants()?;\n\n    // Save\n    self.order_repo.save(order)?;\n\n    // Side effects\n    self.payment_port.charge(order.total(), &order.payment_method)?;\n\n    Ok(())\n  }\n}\n```\n\nQuery Handler:\n\n```rust\n#[derive(HexQueryHandler)]\nstruct OrderHistoryHandler {\n  query_repo: Box<dyn OrderQueryRepository>,\n}\n\nimpl OrderHistoryHandler {\n  fn handle(&self, params: OrderHistoryParams) -> HexResult<Vec<OrderView>> {\n    self.query_repo.get_order_history(\n        &params.customer_id,\n        params.from_date,\n        params.to_date\n    )\n  }\n}\n```\n\n\n5. Infrastructure Layer - Your Technology\n   Infrastructure provides the concrete technology implementations.\n```rust\n#[derive(HexConfig)]\nstruct DatabaseConfig {\n  connection_string: String,\n  pool_size: u32,\n}\n\nimpl DatabaseConfig {\n  fn create_pool(&self) -> PgPool {\n    // Create database connection pool\n    todo!()\n  }\n}\n```\n\n\n### Part 3: CQRS Pattern with hex\n\nhexser supports Command Query Responsibility Segregation (CQRS) out of the box.\n\nWrite Side (Directives):\n\n```rust\n// Directive represents intent to change state\n#[derive(HexDirective)]\nstruct UpdateUserEmail {\n  user_id: UserId,\n  new_email: Email,\n}\n\nimpl UpdateUserEmail {\n  fn validate(&self) -> HexResult<()> {\n    self.new_email.validate()\n  }\n}\n\n// Handler executes the directive\n#[derive(HexDirectiveHandler)]\nstruct UpdateUserEmailHandler {\n  repo: Box<dyn UserRepository>,\n}\n\nimpl UpdateUserEmailHandler {\n  fn handle(&self, directive: UpdateUserEmail) -> HexResult<()> {\n    let mut user = self.repo.find_by_id(&directive.user_id)?\n      .ok_or_else(|| Hexserror::not_found(\"User\", &directive.user_id))?;\n\n    user.email = directive.new_email;\n    self.repo.save(user)?;\n\n    Ok(())\n  }\n}\n```\n\nRead Side (Queries):\n\n```rust\n// Query represents read operation\n#[derive(HexQuery)]\nstruct FindUserByEmail {\n  email: String,\n}\n\n// Handler executes the query\n#[derive(HexQueryHandler)]\nstruct FindUserByEmailHandler {\n  query_repo: Box<dyn UserQueryRepository>,\n}\n\nimpl FindUserByEmailHandler {\n  fn handle(&self, query: FindUserByEmail)\n  -> HexResult<Option<UserView>> {\n    self.query_repo.find_by_email(&query.email)\n  }\n}\n```\n\n\n### Part 4: Testing Your Hexagonal Application\n\nHexagonal architecture makes testing trivial - just mock the ports!\n\nUnit Testing Domain Logic:\n\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_order_invariants() {\n        let order = Order {\n          id: OrderId::new(),\n          customer_id: CustomerId::new(),\n          items: vec![],  // Empty!\n          status: OrderStatus::Pending,\n        };\n\n        assert!(order.check_invariants().is_err());\n    }\n\n    #[test]\n    fn test_email_validation() {\n        let invalid = Email(\"notanemail\".to_string());\n        assert!(invalid.validate().is_err());\n\n        let valid = Email(\"test@example.com\".to_string());\n        assert!(valid.validate().is_ok());\n    }\n}\n```\n\nTesting with Mock Adapters:\n\n```rust\n#[derive(HexAdapter)]\nstruct MockUserRepository {\n  users: std::collections::HashMap<UserId, User>,\n}\n\nimpl Repository<User> for MockUserRepository {\n  fn save(&mut self, user: User) -> HexResult<()> {\n    self.users.insert(user.id.clone(), user);\n    Ok(())\n  }\n}\n\n#[test]\nfn test_create_user_handler() {\n  let mut repo = MockUserRepository {\n    users: std::collections::HashMap::new(),\n  };\n\n  let handler = CreateUserHandler {\n      repo: Box::new(repo),\n  };\n\n  let directive = CreateUserDirective {\n      email: \"test@example.com\".to_string(),\n      name: \"Test User\".to_string(),\n  };\n\n  assert!(handler.handle(directive).is_ok());\n}\n```\n\n\n### Part 5: Error Handling\n\nhexser provides rich, actionable, code-first errors with automatic source location and layering support. Prefer the new macro-based constructors and error codes over manual struct construction.\n\nPreferred: macro + code + guidance\n\n```rust\nfn validate_order(order: &Order) -> HexResult<()> {\n  if order.items.is_empty() {\n    return Err(\n        hexser::hex_domain_error!(\n            hexser::error::codes::domain::INVARIANT_EMPTY,\n            \"Order must contain at least one item\"\n        )\n        .with_next_steps(&[\"Add at least one item to the order\"]) // actionable guidance\n        .with_suggestions(&[\"order.add_item(item)\", \"order.items.push(item)\"]) // quick fixes\n        .with_more_info(\"https://docs.rs/hexser/latest/hexser/error/codes/domain\")\n    );\n  }\n  Ok(())\n}\n```\n\nDisplay output (example):\n\n```text\nE_HEX_001: Order must contain at least one item\nat src/domain/order.rs:42:13\nNext steps:\n- Add at least one item to the order\nSuggestions:\n- order.add_item(item)\n- order.items.push(item)\n```\n\nCookbook\n\n```rust\n// Validation errors (field-aware)\nreturn Err(hexser::error::hex_error::Hexserror::validation_field(\n    \"Title cannot be empty\",\n    \"title\",\n));\n\n// Not Found errors (resource + id)\nreturn Err(hexser::error::hex_error::Hexserror::not_found(\"User\", \"123\")\n    .with_next_step(\"Verify the ID and try again\"));\n\n// Port errors (communication issues)\nlet port_err = hexser::hex_port_error!(\n    hexser::error::codes::port::PORT_TIMEOUT,\n    \"User service timed out\"\n).with_suggestion(\"Increase timeout or retry later\");\n\n// Adapter errors (infra failures) with source error\nfn fetch_from_api(url: &str) -> HexResult<String> {\n    let resp = std::fs::read_to_string(url)\n        .map_err(|ioe| hexser::hex_adapter_error!(\n            hexser::error::codes::adapter::IO_FAILURE, // or API_FAILURE in real HTTP\n            \"Failed to fetch resource\"\n        ).with_source(ioe))?;\n    Ok(resp)\n}\n```\n\n🔥 Amazing Example: Layered mapping (Adapter → Port → Domain)\n\n```rust\n// Adapter layer\nfn db_get_user(id: &str) -> HexResult<User> {\n    let conn = std::fs::read_to_string(\"/tmp/mock-db\").map_err(|e|\n        hexser::hex_adapter_error!(\n            hexser::error::codes::adapter::DB_CONNECTION_FAILURE,\n            \"Database unavailable\"\n        )\n        .with_source(e)\n        .with_next_steps(&[\"Ensure DB is running\", \"Check connection string\"]) \n    )?;\n    // ... parse and return User or NotFound\n    Err(hexser::error::hex_error::Hexserror::not_found(\"User\", id))\n}\n\n// Port layer wraps adapter failure with port context\nfn port_get_user(id: &str) -> HexResult<User> {\n    db_get_user(id).map_err(|e|\n        hexser::hex_port_error!(\n            hexser::error::codes::port::COMMUNICATION_FAILURE,\n            \"UserRepository failed\"\n        ).with_source(e)\n    )\n}\n\n// Domain layer consumes rich errors\nfn ensure_user_exists(id: &str) -> HexResult<()> {\n    let _user = port_get_user(id)?; // `?` preserves full rich error stack\n    Ok(())\n}\n```\n\nNotes\n- All hexser errors implement std::error::Error and the RichError trait (code, message, next_steps, suggestions, location, more_info, source).\n- Prefer hex_domain_error!, hex_port_error!, hex_adapter_error! and constants from hexser::error::codes::*.\n- Use with_source(err) to preserve underlying causes; Display shows a helpful, compact summary.\n\n#### Security: Controlling Source Location in Serialized Errors\n\nWhen using the `serde` feature to serialize errors (e.g., for API responses), source location information (file paths, line numbers, column numbers) can expose internal code structure to clients. **hexser is secure by default** and excludes this sensitive information from serialization unless explicitly enabled.\n\n**Environment Variable: `HEXSER_INCLUDE_SOURCE_LOCATION`**\n\nControl whether source location is included in serialized errors:\n\n```bash\n# Production (default, secure) - source location excluded\n# No environment variable needed\n\n# Development/Debug - include source location\nexport HEXSER_INCLUDE_SOURCE_LOCATION=1\n# or\nexport HEXSER_INCLUDE_SOURCE_LOCATION=true\n```\n\n**Example:**\n\n```rust\nuse hexser::prelude::*;\n\nfn api_handler() -> Result<String, Box<dyn std::error::Error>> {\n    let err = hexser::hex_domain_error!(\n        hexser::error::codes::domain::INVARIANT_VIOLATION,\n        \"Order must have items\"\n    );\n    \n    // Serialize for API response\n    let json = serde_json::to_string(&err)?;\n    \n    // In production (env var not set):\n    // {\"code\":\"E_HEX_001\",\"message\":\"Order must have items\",...}\n    // Source location is excluded for security\n    \n    // In development (HEXSER_INCLUDE_SOURCE_LOCATION=1):\n    // {\"code\":\"E_HEX_001\",\"message\":\"Order must have items\",\n    //  \"location\":{\"file\":\"src/api.rs\",\"line\":42,\"column\":10},...}\n    \n    Ok(json)\n}\n```\n\n**Production Best Practice:**\n- Never set `HEXSER_INCLUDE_SOURCE_LOCATION` in production environments\n- Source location is still captured and available via `Display` formatting for logs\n- Only serialization (JSON/API responses) is affected by this setting\n\n**Affected Error Types:**\n- `DomainError`, `PortError`, `AdapterError` (LayerError-based types)\n- `ValidationError`\n- `NotFoundError`\n- `ConflictError`\n- All errors with `location` fields\n\n\nPart 6: Real-World Example - TODO Application\nLet's build a complete TODO application using hexagonal architecture.\nDomain Layer:\n\n```rust\nuse hexser::prelude::*;\n\n#[derive(Clone, Entity)]\nstruct Todo {\n  id: TodoId,\n  title: String,\n  description: String,\n  completed: bool,\n}\n\n#[derive(Clone, PartialEq, Eq, Hash)]\nstruct TodoId(String);\n\nimpl TodoId {\n  fn new() -> Self {\n    Self(uuid::Uuid::new_v4().to_string())\n  }\n}\n```\n\nPorts Layer:\n\n```rust\n#[derive(HexPort)]\ntrait TodoRepository: Repository<Todo> {\n    fn find_active(&self) -> HexResult<Vec<Todo>>;\n    fn find_completed(&self) -> HexResult<Vec<Todo>>;\n}\n```\n\nAdapters Layer:\n\n```rust\n#[derive(HexAdapter)]\nstruct InMemoryTodoRepository {\n  todos: std::sync::Mutex<Vec<Todo>>,\n}\n\nimpl Repository<Todo> for InMemoryTodoRepository {\n  fn save(&mut self, todo: Todo) -> HexResult<()> {\n      let mut todos = self.todos.lock().unwrap();\n      if let Some(existing) = todos.iter_mut().find(|t| t.id == todo.id) {\n          *existing = todo;\n      } else {\n          todos.push(todo);\n      }\n      Ok(())\n  }\n}\n\nimpl TodoRepository for InMemoryTodoRepository {\n  fn find_active(&self) -> HexResult<Vec<Todo>> {\n    let todos = self.todos.lock().unwrap();\n    Ok(todos.iter().filter(|t| !t.completed).cloned().collect())\n  }\n\n  fn find_completed(&self) -> HexResult<Vec<Todo>> {\n    let todos = self.todos.lock().unwrap();\n    Ok(todos.iter().filter(|t| t.completed).cloned().collect())\n  }\n}\n```\n\nApplication Layer:\n\n```rust\n#[derive(HexDirective)]\nstruct CreateTodoDirective {\n    title: String,\n    description: String,\n}\n\nimpl CreateTodoDirective {\n    fn validate(&self) -> HexResult<()> {\n        if self.title.is_empty() {\n            return Err(Hexserror::validation_field(\"Title cannot be empty\", \"title\"));\n        }\n        Ok(())\n    }\n}\n\n#[derive(HexDirectiveHandler)]\nstruct CreateTodoHandler {\n    repo: Box<dyn TodoRepository>,\n}\n\nimpl CreateTodoHandler {\n    fn handle(&self, directive: CreateTodoDirective) -> HexResult<()> {\n        directive.validate()?;\n\n        let todo = Todo {\n            id: TodoId::new(),\n            title: directive.title,\n            description: directive.description,\n            completed: false,\n        };\n\n        self.repo.save(todo)?;\n        Ok(())\n    }\n}\n```\n\n---\n\n## 🎓 Advanced Patterns\nEvent Sourcing\n\n```rust\n#[derive(HexAggregate)]\nstruct OrderAggregate {\n  id: OrderId,\n  uncommitted_events: Vec<Box<dyn DomainEvent>>,\n}\n\nimpl OrderAggregate {\n  fn place_order(&mut self, items: Vec<OrderItem>) -> HexResult<()> {\n    // Validate\n    if items.is_empty() {\n      return Err(hexser::hex_domain_error!(\n        hexser::error::codes::domain::INVARIANT_EMPTY,\n        \"Order must have items\"\n      ));\n    }\n\n    // Create event\n    let event = OrderPlaced {\n        order_id: self.id.clone(),\n        items,\n        timestamp: current_timestamp(),\n    };\n\n    // Apply event\n    self.apply_event(&event);\n\n    // Record event\n    self.uncommitted_events.push(Box::new(event));\n\n    Ok(())\n  }\n\n  fn apply_event(&mut self, event: &dyn DomainEvent) {\n      // Update state based on event\n  }\n}\n```\n\nDependency Injection\n\n```rust\nstruct ApplicationContext {\n    user_repo: Box<dyn UserRepository>,\n    order_repo: Box<dyn OrderRepository>,\n    payment_port: Box<dyn PaymentPort>,\n}\n\nimpl ApplicationContext {\n    fn new_production() -> Self {\n        Self {\n            user_repo: Box::new(PostgresUserRepository::new()),\n            order_repo: Box::new(PostgresOrderRepository::new()),\n            payment_port: Box::new(StripePaymentGateway::new()),\n        }\n    }\n\n    fn new_test() -> Self {\n        Self {\n            user_repo: Box::new(MockUserRepository::new()),\n            order_repo: Box::new(MockOrderRepository::new()),\n            payment_port: Box::new(MockPaymentGateway::new()),\n        }\n    }\n}\n```\n\n\n## 📊 Knowledge Graph\n\n```\nhexser/\n├── domain/              [Core Business Logic - No Dependencies]\n│   ├── HexEntity        - Identity-based objects\n│   ├── HexValueItem     - Value-based objects\n│   ├── Aggregate        - Consistency boundaries\n│   ├── DomainEvent      - Significant occurrences\n│   └── DomainService    - Cross-entity operations\n│\n├── ports/               [Interface Definitions]\n│   ├── Repository       - Persistence abstraction\n│   ├── UseCase          - Business operations\n│   ├── Query            - Read-only operations (CQRS)\n│   ├── InputPort        - Entry points\n│   └── OutputPort       - External system interfaces\n│\n├── adapters/            [Concrete Implementations]\n│   ├── Adapter          - Port implementations\n│   └── Mapper           - Data transformation\n│\n├── application/         [Orchestration Layer]\n│   ├── Directive        - Write operations (CQRS)\n│   ├── DirectiveHandler - Directive execution\n│   └── QueryHandler     - Query execution\n│\n├── infrastructure/      [Technology Layer]\n│   └── Config           - Infrastructure setup\n│\n├── error/               [Rich Error Types]\n│   └── Hexserror         - Actionable errors\n│\n└── graph/               [Introspection - Phase 2+]\n    ├── Layer            - Architectural layers\n    ├── Role             - Component roles\n    ├── Relationship     - Component connections\n    └── NodeId           - Unique identification\n```\n\n## 💡 Design Philosophy\n- \"Language of the Language\": Use Rust's type system to express architecture\n- Zero Boilerplate: Derive everything, configure nothing\n- Compile-Time Guarantees: Catch errors before runtime\n- Rich Errors: Every error is helpful and actionable\n- Self-Documenting: Graph reveals architecture automatically\n- Testability First: Mock anything, test everything\n\n## 🤝 Contributing\nWe welcome contributions! This crate follows strict coding standards:\n- One item per file: Each file contains one logical item\n- No imports: Fully qualified paths (except std prelude)\n- Documentation: Every item has //! and /// docs\n- In-file tests: Tests live with the code they test\n- No unsafe: Safe Rust only\n- Rust 2024: Latest edition\n\nSee CONTRIBUTING.md for details.\n\n## 📄 License\nLicensed under either of:\n- Apache License, Version 2.0 (LICENSE-APACHE)\n- MIT license (LICENSE-MIT)\n\nat your option.\n\n## 🙏 Acknowledgments\nInspired by:\n- CEQRS by Scott Wyatt\n- N Lang by Scott Wyatt\n- Domain-Driven Design by Eric Evans\n- Hexagonal Architecture by Alistair Cockburn\n- Clean Architecture by Robert C. Martin\n- Rust's type system and error handling\n- The Rust community's commitment to excellence\n\n## 📚 Additional Resources\n- Hexagonal Architecture Explained\n- Domain-Driven Design\n- CQRS Pattern\n- Ports and Adapters\n\n## 🎯 Examples & Tutorials\nThe hex crate includes comprehensive examples and tutorials to help you learn hexagonal architecture.\n\nRunning Examples\n\n```bash\ncargo run --example simple_todo\n```\n\n\n\n---\n\n## 🧪 Potions (copy-friendly examples)\n\nLooking for concrete, minimal examples you can paste into your app?\nCheck out the Potions crate in this workspace:\n\n- Path: ./hexser_potions\n- Crate: hexser_potions\n- Focus: small, mixable examples (auth signup, CRUD, etc.)\n\nAdd to your project via workspace path:\n\n```toml\n[dependencies]\nhexser_potions = { path = \"../hexser_potions\", version = \"0.4.5\" }\n```\n\nThen in code:\n\n```rust\nuse hexser_potions::auth::{SignUpUser, InMemoryUserRepository, execute_signup};\n```\n\n\n---\n\n## ⚙️ Static (non-dyn) DI — WASM-friendly\n\nWhen you want zero dynamic dispatch and the smallest possible runtime footprint (including on wasm32-unknown-unknown), use the new static DI utilities.\n\nFeature flags:\n- Enabled by default: `static-di`\n- Opt-in for dyn container (tokio-based): `container`\n\nStatic DI provides two simple building blocks:\n- `StaticContainer<T>`: owns your fully built object graph\n- `hex_static! { ... }` macro: builds the graph from a block without any `dyn`\n\nExample:\n\n```rust,ignore\nuse hexser::prelude::*;\n\n#[derive(Clone, Debug)]\nstruct Repo;\n#[derive(Clone, Debug)]\nstruct Service { repo: Repo }\n\nlet app = hexser::hex_static!({\n    let repo = Repo;\n    let service = Service { repo: repo.clone() };\n    (repo, service)\n});\n\nlet (repo, service) = app.into_inner();\n```\n\nWASM guidance:\n- Default features are WASM-friendly (no tokio). Keep `container` disabled for wasm.\n- Use `static-di` (default) and avoid the dyn container for maximum compatibility.\n\n\n\n---\n\n## Repository: Filter-based queries (vNext)\n\nWe are migrating the repository port away from id-centric methods (find_by_id/find_all) toward a generic, filter-oriented API that better models your domain while staying storage-agnostic. The new QueryRepository trait introduces domain-owned Filter and SortKey types plus FindOptions for sorting and pagination.\n\nHighlights:\n- Define small Filter and SortKey enums/structs in your domain\n- Use find_one for unique lookups and find for lists with sorting/pagination\n- Legacy methods are still available but deprecated; prefer the new API\n\nExample:\n\n```rust\nuse hexser::prelude::*;\nuse hexser::ports::repository::{QueryRepository, FindOptions, Sort, Direction};\n\n#[derive(Entity, Clone, Debug)]\nstruct User { id: String, email: String, created_at: u64 }\n\n// Domain-owned query types\n#[derive(Clone, Debug)]\nenum UserFilter {\n    ById(String),\n    ByEmail(String),\n    All,\n}\n\n#[derive(Clone, Copy, Debug, PartialEq, Eq)]\nenum UserSortKey { CreatedAt, Email }\n\n#[derive(Default)]\nstruct InMemoryUserRepository { users: Vec<User> }\n\nimpl Repository<User> for InMemoryUserRepository {\n    fn save(&mut self, user: User) -> HexResult<()> { if let Some(i)=self.users.iter().position(|u| u.id==user.id){self.users[i]=user;} else { self.users.push(user);} Ok(()) }\n}\n\nimpl QueryRepository<User> for InMemoryUserRepository {\n    type Filter = UserFilter;\n    type SortKey = UserSortKey;\n\n    fn find_one(&self, f: &Self::Filter) -> HexResult<Option<User>> {\n        Ok(self.users.iter().find(|u| match f { UserFilter::ById(id)=>&u.id==id, UserFilter::ByEmail(e)=>&u.email==e, UserFilter::All=>true }).cloned())\n    }\n\n    fn find(&self, f: &Self::Filter, opts: FindOptions<Self::SortKey>) -> HexResult<Vec<User>> {\n        let mut items: Vec<_> = self.users.iter().filter(|u| match f { UserFilter::ById(id)=>&u.id==id, UserFilter::ByEmail(e)=>&u.email==e, UserFilter::All=>true }).cloned().collect();\n        if let Some(sorts) = opts.sort {\n            for s in sorts.into_iter().rev() {\n                match (s.key, s.direction) {\n                    (UserSortKey::CreatedAt, Direction::Asc) => items.sort_by_key(|u| u.created_at),\n                    (UserSortKey::CreatedAt, Direction::Desc) => items.sort_by_key(|u| std::cmp::Reverse(u.created_at)),\n                    (UserSortKey::Email, Direction::Asc) => items.sort_by(|a,b| a.email.cmp(&b.email)),\n                    (UserSortKey::Email, Direction::Desc) => items.sort_by(|a,b| b.email.cmp(&a.email)),\n                }\n            }\n        }\n        let offset = opts.offset.unwrap_or(0) as usize;\n        let limit = opts.limit.map(|l| l as usize).unwrap_or_else(|| items.len().saturating_sub(offset));\n        let end = offset.saturating_add(limit).min(items.len());\n        Ok(items.into_iter().skip(offset).take(end.saturating_sub(offset)).collect())\n    }\n}\n\nfn main() -> HexResult<()> {\n    let repo = InMemoryUserRepository::default();\n    // Unique lookup\n    let _ = <InMemoryUserRepository as QueryRepository<User>>::find_one(&repo, &UserFilter::ByEmail(\"alice@ex.com\".into()))?;\n\n    // List with pagination\n    let opts = FindOptions { sort: Some(vec![Sort { key: UserSortKey::CreatedAt, direction: Direction::Desc }]), limit: Some(25), offset: Some(0) };\n    let _page = <InMemoryUserRepository as QueryRepository<User>>::find(&repo, &UserFilter::All, opts)?;\n    Ok(())\n}\n```\n\nMigration tips:\n- find_by_id(id) -> find_one(&Filter::ById(id))\n- find_all() -> find(&Filter::All, FindOptions::default())\n- Add sorting/pagination via FindOptions { sort, limit, offset }\n\nFor more details, see MIGRATION_GUIDE.md and docs/core-concepts.md.\n\n### v0.4 QueryRepository Examples (5+)\n\nThe following focused examples demonstrate the new query-first API using domain-owned Filter and SortKey types. These snippets avoid deprecated methods and illustrate common tasks.\n\n1) Unique lookup with find_one\n\n```rust\n// Given: domain types User, UserFilter::ByEmail(String)\nlet repo = InMemoryUserRepository::default();\nlet maybe_user = <InMemoryUserRepository as hexser::ports::repository::QueryRepository<User>>\n    ::find_one(&repo, &UserFilter::ByEmail(String::from(\"alice@example.com\")))?;\n```\n\n2) Listing with multi-key sorting (Email asc, CreatedAt desc)\n\n```rust\nlet opts = hexser::ports::repository::FindOptions {\n    sort: Some(vec![\n        hexser::ports::repository::Sort { key: UserSortKey::Email, direction: hexser::ports::repository::Direction::Asc },\n        hexser::ports::repository::Sort { key: UserSortKey::CreatedAt, direction: hexser::ports::repository::Direction::Desc },\n    ]),\n    limit: None,\n    offset: None,\n};\nlet users = <InMemoryUserRepository as hexser::ports::repository::QueryRepository<User>>::find(\n    &repo,\n    &UserFilter::All,\n    opts,\n)?;\n```\n\n3) Pagination (page size 10, second page)\n\n```rust\nlet opts = hexser::ports::repository::FindOptions { sort: None, limit: Some(10), offset: Some(10) };\nlet page = <InMemoryUserRepository as hexser::ports::repository::QueryRepository<User>>::find(&repo, &UserFilter::All, opts)?;\n```\n\n4) Existence check\n\n```rust\nlet exists = <InMemoryUserRepository as hexser::ports::repository::QueryRepository<User>>::exists(\n    &repo,\n    &UserFilter::ByEmail(String::from(\"bob@example.com\")),\n)?;\n```\n\n5) Count matching entities\n\n```rust\nlet total = <InMemoryUserRepository as hexser::ports::repository::QueryRepository<User>>::count(\n    &repo,\n    &UserFilter::All,\n)?;\n```\n\n6) Delete by filter (returns removed count)\n\n```rust\nlet removed = <InMemoryUserRepository as hexser::ports::repository::QueryRepository<User>>::delete_where(\n    &mut repo.clone(),\n    &UserFilter::ByEmail(String::from(\"bob@example.com\")),\n)?;\n```\n\n---\n\n## 🤖 AI Context Export (CLI)\n\nExport a machine-readable JSON describing your project's architecture for AI assistants and tooling.\n\nRequirements:\n- Enable the `ai` feature (serde/serde_json are included automatically).\n\nCommands:\n\n```sh\n# Build and run the exporter (prints JSON to stdout)\ncargo run -p hexser --features ai --bin hex-ai-export\n\n# Save to a file\ncargo run -p hexser --features ai --bin hex-ai-export --quiet > target/ai-context.json\n```\n\nWhat it does:\n- Builds the current `HexGraph` from the component registry\n- Generates an `AIContext` via `hexser::ai::ContextBuilder`\n- Serializes to JSON with a stable field order\n\nNotes:\n- The binary `hex-ai-export` is only built when the `ai` feature is enabled.\n- For reproducible diffs, commit `target/ai-context.json` or generate it in CI as an artifact.\n\n### 🧠 AI Agent Pack (All-in-One)\n\nExport a comprehensive, single-file JSON that bundles:\n- AIContext (machine-readable architecture)\n- Guidelines snapshot (rules enforced for agents)\n- Embedded key docs (README, ERROR_GUIDE, and local AI/guideline prompts when present)\n\nCommands:\n\n```sh\n# Print Agent Pack JSON to stdout\ncargo run -p hexser --features ai --bin hex-ai-pack\n\n# Save to a file\ncargo run -p hexser --features ai --bin hex-ai-pack --quiet > target/ai-pack.json\n```\n\nNotes:\n- Missing optional docs are skipped gracefully. The pack remains valid JSON.\n- Use this artifact as the single source of truth for external AIs and tools when proposing changes.\n\n---\n\n## 🔌 MCP Server (Model Context Protocol)\n\nHexser includes a built-in MCP (Model Context Protocol) server that exposes your project's architecture to AI assistants via a standardized JSON-RPC interface. This enables AI tools like Claude Desktop, Cline, and other MCP-compatible clients to query your architecture in real-time.\n\nRequirements:\n- Enable the `mcp` feature (automatically includes `ai`, `serde`, and `serde_json`).\n\n### Running the MCP Server\n\n```sh\n# Run the MCP server (stdio transport)\ncargo run -p hexser --features mcp --bin hex-mcp-server\n\n# The server reads JSON-RPC requests from stdin and writes responses to stdout\n```\n\n### Available MCP Resources\n\nThe MCP server exposes two primary resources:\n\n1. **`hexser://context`** - Machine-readable architecture context (AIContext JSON)\n   - Current component graph\n   - Layer relationships\n   - Architectural constraints\n   - Validation rules\n\n2. **`hexser://pack`** - Comprehensive Agent Pack (all-in-one JSON)\n   - AIContext (architecture)\n   - Guidelines snapshot (coding rules)\n   - Embedded documentation (README, ERROR_GUIDE, etc.)\n\n### Integration with AI Assistants\n\nConfigure your AI assistant to use the MCP server:\n\n**Claude Desktop (config.json):**\n```json\n{\n  \"mcpServers\": {\n    \"hexser\": {\n      \"command\": \"cargo\",\n      \"args\": [\"run\", \"-p\", \"hexser\", \"--features\", \"mcp\", \"--bin\", \"hex-mcp-server\"],\n      \"cwd\": \"/path/to/your/hexser/project\"\n    }\n  }\n}\n```\n\n**Cline / Other MCP Clients:**\nFollow the client-specific configuration to add the above command as an MCP server endpoint.\n\n### What the MCP Server Does\n\n- Accepts JSON-RPC 2.0 requests via stdin\n- Implements the Model Context Protocol specification\n- Provides `initialize`, `resources/list`, and `resources/read` methods\n- Serves architecture data from the live `HexGraph` registry\n- Enables AI assistants to understand your project structure in real-time\n\nNotes:\n- The `hex-mcp-server` binary is only built when the `mcp` feature is enabled.\n- The server uses stdio transport (line-delimited JSON-RPC messages).\n- For production use, consider wrapping in a process manager or systemd service.\n\n---\n\n## 🌦 REST Adapter Example: WeatherPort\n\nHexser includes a complete example of a REST-based adapter using `reqwest::blocking` and `serde_json`. This adapter connects to an external weather API and maps JSON responses to domain models with robust error handling.\n\n### Domain Model\n\n```rust\n// Domain: Forecast value object (in hexser::domain::forecast)\npub struct Forecast {\n    city: String,\n    temperature_c: f64,\n    condition: String,\n    observed_at_iso: Option<String>,\n}\n```\n\n### Port Definition\n\n```rust\n// Port: WeatherPort trait (in hexser::ports::weather_port)\npub trait WeatherPort {\n    fn get_forecast(&self, city: &str) -> HexResult<Forecast>;\n}\n```\n\n### Adapter Implementation\n\n```rust\n// Adapter: RestWeatherAdapter (self-contained in examples/weather_adapter.rs)\npub struct RestWeatherAdapter {\n    api_base_url: String,\n    client: reqwest::blocking::Client,\n}\n\nimpl RestWeatherAdapter {\n    pub fn new(api_base_url: String) -> Self {\n        let client = reqwest::blocking::Client::builder()\n            .timeout(std::time::Duration::from_secs(10))\n            .build()\n            .expect(\"Failed to build reqwest client\");\n        Self { api_base_url, client }\n    }\n}\n\nimpl WeatherPort for RestWeatherAdapter {\n    fn get_forecast(&self, city: &str) -> HexResult<Forecast> {\n        let url = format!(\"{}?city={}\", self.api_base_url, city);\n        \n        // HTTP call with error mapping (API_FAILURE)\n        let response = self.client.get(&url)\n            .send()\n            .map_err(|e| {\n                Hexserror::adapter(\n                    codes::adapter::API_FAILURE,\n                    \"Failed to connect to weather API\"\n                )\n                .with_source(e)\n                .with_next_steps(&[\"Verify API endpoint\", \"Check network\"])\n            })?;\n        \n        // Deserialize JSON with error mapping (MAPPING_FAILURE)\n        let api_response: ApiWeatherResponse = serde_json::from_str(&response.text()?)\n            .map_err(|e| {\n                Hexserror::adapter(\n                    codes::adapter::MAPPING_FAILURE,\n                    \"Failed to parse JSON response\"\n                )\n                .with_source(e)\n            })?;\n        \n        // Map to domain model\n        Forecast::new(\n            api_response.city,\n            api_response.temp_c,\n            api_response.condition,\n            api_response.observed_at,\n        )\n    }\n}\n```\n\nThis complete example is available at `examples/weather_adapter.rs`. Run with:\n```bash\ncargo run --example weather_adapter\n```\n\n---\n\n## 🔐 Integrating User Authentication Potions\n\nWhen integrating pre-built authentication patterns from `hexser_potions`, you must connect the Potion's defined Ports to your own concrete adapters for databases and session management.\n\n### Step 1: Define Your Ports\n\n```rust\n// Port for user persistence\ntrait UserRepository: Repository<User> {\n    fn find_by_username(&self, username: &str) -> HexResult<Option<User>>;\n    fn find_by_email(&self, email: &str) -> HexResult<Option<User>>;\n}\n\n// Port for session management (new for question 4)\ntrait SessionPort {\n    fn create_session(&self, user_id: &str, ttl_secs: u64) -> HexResult<String>;\n    fn validate_session(&self, token: &str) -> HexResult<Option<String>>;\n    fn revoke_session(&self, token: &str) -> HexResult<()>;\n}\n```\n\n### Step 2: Implement Database Adapter\n\n```rust\n// Concrete PostgreSQL adapter\nstruct PostgresUserRepository {\n    pool: sqlx::PgPool,\n}\n\nimpl Repository<User> for PostgresUserRepository {\n    fn save(&mut self, user: User) -> HexResult<()> {\n        // Execute INSERT/UPDATE via sqlx\n        sqlx::query!(\"INSERT INTO users (id, username, email, password_hash) VALUES ($1, $2, $3, $4)\",\n            user.id, user.username, user.email, user.password_hash)\n            .execute(&self.pool)\n            .await\n            .map_err(|e| Hexserror::adapter(codes::adapter::DB_WRITE_FAILURE, \"Failed to save user\")\n                .with_source(e))?;\n        Ok(())\n    }\n}\n\nimpl UserRepository for PostgresUserRepository {\n    fn find_by_username(&self, username: &str) -> HexResult<Option<User>> {\n        sqlx::query_as!(User, \"SELECT * FROM users WHERE username = $1\", username)\n            .fetch_optional(&self.pool)\n            .await\n            .map_err(|e| Hexserror::adapter(codes::adapter::DB_READ_FAILURE, \"Query failed\")\n                .with_source(e))\n    }\n}\n```\n\n### Step 3: Implement Session Adapter (Redis or In-Memory)\n\n```rust\n// Redis-based session adapter\nstruct RedisSessionAdapter {\n    client: redis::Client,\n}\n\nimpl SessionPort for RedisSessionAdapter {\n    fn create_session(&self, user_id: &str, ttl_secs: u64) -> HexResult<String> {\n        let token = uuid::Uuid::new_v4().to_string();\n        let mut conn = self.client.get_connection()\n            .map_err(|e| Hexserror::adapter(codes::adapter::CONNECTION_FAILURE, \"Redis unavailable\")\n                .with_source(e))?;\n        \n        redis::cmd(\"SETEX\")\n            .arg(format!(\"session:{}\", token))\n            .arg(ttl_secs)\n            .arg(user_id)\n            .query(&mut conn)\n            .map_err(|e| Hexserror::adapter(codes::adapter::DB_WRITE_FAILURE, \"Session write failed\")\n                .with_source(e))?;\n        \n        Ok(token)\n    }\n    \n    fn validate_session(&self, token: &str) -> HexResult<Option<String>> {\n        let mut conn = self.client.get_connection()?;\n        let user_id: Option<String> = redis::cmd(\"GET\")\n            .arg(format!(\"session:{}\", token))\n            .query(&mut conn)\n            .map_err(|e| Hexserror::adapter(codes::adapter::DB_READ_FAILURE, \"Session read failed\")\n                .with_source(e))?;\n        Ok(user_id)\n    }\n    \n    fn revoke_session(&self, token: &str) -> HexResult<()> {\n        let mut conn = self.client.get_connection()?;\n        redis::cmd(\"DEL\")\n            .arg(format!(\"session:{}\", token))\n            .query(&mut conn)\n            .map_err(|e| Hexserror::adapter(codes::adapter::DB_WRITE_FAILURE, \"Session delete failed\")\n                .with_source(e))?;\n        Ok(())\n    }\n}\n```\n\n### Step 4: Wire Adapters to Application\n\n```rust\n// Application context with wired adapters\nstruct AppContext {\n    user_repo: Box<dyn UserRepository>,\n    session_port: Box<dyn SessionPort>,\n}\n\nimpl AppContext {\n    fn new_production(db_pool: sqlx::PgPool, redis_client: redis::Client) -> Self {\n        Self {\n            user_repo: Box::new(PostgresUserRepository { pool: db_pool }),\n            session_port: Box::new(RedisSessionAdapter { client: redis_client }),\n        }\n    }\n}\n```\n\n---\n\n## 🔄 Transactional Directives: ProcessOrder Example\n\nWhen a directive involves multiple repository operations that must succeed or fail atomically (e.g., decrementing stock and creating an order), use a database transaction and pass it explicitly to each repository call.\n\n### Port Definitions\n\n```rust\n// Ports accepting a transaction context\ntrait ProductRepository {\n    fn decrement_stock(&self, tx: &mut PgTransaction, product_id: &str, qty: u32) -> HexResult<()>;\n}\n\ntrait OrderRepository {\n    fn create_order(&self, tx: &mut PgTransaction, order: Order) -> HexResult<()>;\n}\n\ntrait EventBus {\n    fn publish(&self, event: OrderCreated) -> HexResult<()>;\n}\n```\n\n### Directive Handler with Transaction\n\n```rust\nstruct ProcessOrderHandler {\n    product_repo: Box<dyn ProductRepository>,\n    order_repo: Box<dyn OrderRepository>,\n    event_bus: Box<dyn EventBus>,\n    db_pool: sqlx::PgPool,\n}\n\nimpl ProcessOrderHandler {\n    async fn handle(&self, directive: ProcessOrderDirective) -> HexResult<()> {\n        // Begin transaction\n        let mut tx = self.db_pool.begin()\n            .await\n            .map_err(|e| Hexserror::adapter(codes::adapter::DB_CONNECTION_FAILURE, \"Failed to begin transaction\")\n                .with_source(e))?;\n        \n        // 1) Decrement stock for each product (atomic within tx)\n        for item in &directive.items {\n            self.product_repo.decrement_stock(&mut tx, &item.product_id, item.quantity)\n                .await\n                .map_err(|e| {\n                    // Rollback is automatic on error via Drop\n                    Hexserror::domain(codes::domain::INVARIANT_VIOLATION, \"Insufficient stock\")\n                        .with_source(e)\n                })?;\n        }\n        \n        // 2) Create order record (atomic within tx)\n        let order = Order::new(directive.customer_id, directive.items)?;\n        self.order_repo.create_order(&mut tx, order.clone())\n            .await\n            .map_err(|e| {\n                Hexserror::adapter(codes::adapter::DB_WRITE_FAILURE, \"Failed to create order\")\n                    .with_source(e)\n            })?;\n        \n        // Commit transaction (all-or-nothing)\n        tx.commit()\n            .await\n            .map_err(|e| Hexserror::adapter(codes::adapter::DB_WRITE_FAILURE, \"Transaction commit failed\")\n                .with_source(e))?;\n        \n        // 3) Dispatch event (after commit)\n        let event = OrderCreated { order_id: order.id.clone(), timestamp: now() };\n        self.event_bus.publish(event)?;\n        \n        Ok(())\n    }\n}\n```\n\n### Adapter Implementation (PostgreSQL)\n\n```rust\nstruct PostgresProductRepository;\n\nimpl ProductRepository for PostgresProductRepository {\n    async fn decrement_stock(&self, tx: &mut PgTransaction<'_>, product_id: &str, qty: u32) -> HexResult<()> {\n        let rows_affected = sqlx::query!(\n            \"UPDATE products SET stock = stock - $1 WHERE id = $2 AND stock >= $1\",\n            qty as i32, product_id\n        )\n        .execute(tx)\n        .await\n        .map_err(|e| Hexserror::adapter(codes::adapter::DB_WRITE_FAILURE, \"Stock update failed\")\n            .with_source(e))?\n        .rows_affected();\n        \n        if rows_affected == 0 {\n            return Err(Hexserror::domain(codes::domain::INVARIANT_VIOLATION, \"Insufficient stock or product not found\"));\n        }\n        Ok(())\n    }\n}\n```\n\n**Key Points:**\n- Pass `&mut PgTransaction` (or equivalent) to all repository methods within the transaction.\n- Rollback is automatic via Rust's `Drop` trait if any error occurs before `commit()`.\n- Publish events only after successful commit to ensure consistency.\n\n---\n\n## 🔗 Composite Adapters: ProfileRepository Example\n\nWhen data must be fetched from multiple sources (e.g., SQL for core profile, NoSQL for preferences), implement a composite adapter that queries both, handles failures gracefully, and optionally caches results.\n\n### Port Definition\n\n```rust\ntrait ProfileRepository {\n    fn find_by_id(&self, user_id: &str) -> HexResult<Profile>;\n}\n```\n\n### Composite Adapter Implementation\n\n```rust\nstruct CompositeProfileRepository {\n    sql_db: sqlx::PgPool,\n    nosql_client: mongodb::Client,\n    cache: std::sync::Arc<std::sync::Mutex<lru::LruCache<String, Profile>>>,\n}\n\nimpl CompositeProfileRepository {\n    fn new(sql_db: sqlx::PgPool, nosql_client: mongodb::Client, cache_size: usize) -> Self {\n        Self {\n            sql_db,\n            nosql_client,\n            cache: std::sync::Arc::new(std::sync::Mutex::new(lru::LruCache::new(cache_size))),\n        }\n    }\n}\n\nimpl ProfileRepository for CompositeProfileRepository {\n    async fn find_by_id(&self, user_id: &str) -> HexResult<Profile> {\n        // Check cache first\n        {\n            let mut cache = self.cache.lock().unwrap();\n            if let Some(cached) = cache.get(user_id) {\n                return Ok(cached.clone());\n            }\n        }\n        \n        // 1) Fetch core profile from SQL (primary source, must succeed)\n        let core_profile: SqlProfileRow = sqlx::query_as!(\n            SqlProfileRow,\n            \"SELECT id, username, email, created_at FROM users WHERE id = $1\",\n            user_id\n        )\n        .fetch_one(&self.sql_db)\n        .await\n        .map_err(|e| match e {\n            sqlx::Error::RowNotFound => Hexserror::not_found(\"Profile\", user_id),\n            _ => Hexserror::adapter(codes::adapter::DB_READ_FAILURE, \"SQL query failed\")\n                .with_source(e)\n                .with_next_step(\"Check database connectivity\"),\n        })?;\n        \n        // 2) Enrich with preferences from NoSQL (optional, degrade gracefully)\n        let collection = self.nosql_client.database(\"app\").collection::<bson::Document>(\"user_prefs\");\n        let prefs_result = collection.find_one(bson::doc! { \"user_id\": user_id }, None).await;\n        \n        let preferences = match prefs_result {\n            Ok(Some(doc)) => {\n                // Parse preferences from document\n                Preferences::from_bson(&doc).unwrap_or_default()\n            }\n            Ok(None) => {\n                // User has no preferences document yet; use defaults\n                Preferences::default()\n            }\n            Err(e) => {\n                // NoSQL source failed; log warning and use defaults (degrade gracefully)\n                eprintln!(\"Warning: Failed to fetch preferences for {}: {}\", user_id, e);\n                Preferences::default()\n            }\n        };\n        \n        // 3) Combine into domain model\n        let profile = Profile {\n            id: core_profile.id,\n            username: core_profile.username,\n            email: core_profile.email,\n            created_at: core_profile.created_at,\n            preferences,\n        };\n        \n        // 4) Cache result\n        {\n            let mut cache = self.cache.lock().unwrap();\n            cache.put(user_id.to_string(), profile.clone());\n        }\n        \n        Ok(profile)\n    }\n}\n```\n\n### Handling Data Inconsistencies\n\n- **Primary Source Failure:** Return `Hexserror::Adapter` or `Hexserror::NotFound` with actionable guidance.\n- **Secondary Source Failure:** Degrade gracefully by logging a warning and using defaults (e.g., `Preferences::default()`).\n- **Caching Strategy:** Use an LRU cache with TTL to reduce load; invalidate on writes.\n- **Stale Data:** Implement cache invalidation hooks or TTL-based expiry for eventually-consistent NoSQL data.\n\n### Caching Strategies\n\n1. **Read-Through Cache:** Check cache before querying databases (shown above).\n2. **Write-Through Cache:** Invalidate or update cache on writes.\n3. **TTL-Based Expiry:** Use a cache with time-to-live for each entry.\n\n```rust\n// Example: TTL-based cache wrapper\nstruct TtlCache<K, V> {\n    cache: lru::LruCache<K, (V, std::time::Instant)>,\n    ttl: std::time::Duration,\n}\n\nimpl<K: std::hash::Hash + Eq, V: Clone> TtlCache<K, V> {\n    fn get(&mut self, key: &K) -> Option<V> {\n        if let Some((value, inserted_at)) = self.cache.get(key) {\n            if inserted_at.elapsed() < self.ttl {\n                return Some(value.clone());\n            }\n        }\n        None\n    }\n}\n```\n\n---\n","bytes":58251},{"path":"/Users/scott/@squillo/n-rust/nlang_hex/hexser/src/error/ERROR_GUIDE.md","title":"# Hexser Error System Guide","content":"# Hexser Error System Guide\n\nComplete guide to using the Hexser error handling system for building robust, maintainable applications with rich, actionable error information.\n\n## Table of Contents\n\n1. [Quick Start](#quick-start)\n2. [Error Types](#error-types)\n3. [Error Construction](#error-construction)\n4. [Error Chaining](#error-chaining)\n5. [Best Practices](#best-practices)\n6. [Error Codes Reference](#error-codes-reference)\n7. [Examples](#examples)\n\n---\n\n## Quick Start\n\n### Basic Error Creation\n\nCreating rich, actionable errors is straightforward using the builder pattern:\n\n```rust\nuse hexser::error::{Hexserror, codes};\n\n// Domain error with next steps\nlet err = Hexserror::domain(codes::domain::INVARIANT_VIOLATION, \"Order must contain items\")\n    .with_next_step(\"Add at least one item to the order\")\n    .with_suggestion(\"order.add_item(item)\");\n\n// Validation error with field context\nlet err = Hexserror::validation_field(\"Email format is invalid\", \"email\")\n    .with_suggestion(\"Use format: user@example.com\");\n\n// Not found error\nlet err = Hexserror::not_found(\"User\", \"user-123\");\n\n```\n\n## Error Display\nAll errors implement std::fmt::Display with structured, human-readable output:\n\n```text \nError [E_HEX_002]: Order must contain items\nNext Steps: Add at least one item to the order\nSuggestions: order.add_item(item)\nSource: src/domain/order.rs:45:12\n```\n\n\n## Error Types\n\nThe Hexser error system provides specialized error types for different architectural layers and failure scenarios.\n\nHexserror (Main Error Type)\n\nHexserror is the primary error enum that wraps all layer-specific errors:\n\n```rust\npub enum Hexserror {\n  Domain(DomainError),\n  Port(PortError),\n  Adapter(AdapterError),\n  Validation(ValidationError),\n  NotFound(NotFoundError),\n  Conflict(ConflictError),\n}\n```\n\n## Layer-Specific Errors\n\n### DomainError\n\nRepresents business rule violations and invariant failures in the domain layer:\n\n```rust\nuse hexser::error::{Hexserror, codes};\n\nlet err = Hexserror::domain(\n    codes::domain::INVARIANT_VIOLATION,\n    \"Account balance cannot be negative\"\n)\n.with_next_step(\"Ensure sufficient funds before withdrawal\")\n.with_suggestion(\"Check account.balance >= amount\");\n```\n\nCommon Use Cases:\n- Aggregate invariant violations\n- Business rule failures\n- Invalid state transitions\n- PortError\n\n- Represents failures in port interfaces between domain and adapters:\n\n```rust\nuse hexser::error::port_error;\n\nlet err = port_error::communication_failure(\"Database connection lost\");\nlet err = port_error::port_timeout(\"UserRepository\");\nlet err = port_error::port_not_found(\"PaymentGateway\");\n```\n\nCommon Use Cases:\n- Port communication failures\n- Missing port implementations\n- Port operation timeouts\n- AdapterError\nRepresents infrastructure and external service failures:\n\n```rust\nuse hexser::error::adapter_error;\n\nlet err = adapter_error::connection_failed(\"PostgreSQL\", \"Connection refused\");\nlet err = adapter_error::api_failure(\"Payment API returned 503\");\nlet err = adapter_error::mapping_failure(\"Cannot map DTO to entity\");\n```\n\nCommon Use Cases:\n- Database connection failures\n- External API errors\n- Data mapping issues\n- File I/O failures\n- ValidationError\n\nRepresents input validation failures with field-specific context:\n\n```rust\nuse hexser::error::{Hexserror, codes};\n\nlet err = Hexserror::validation(\"Required field missing\")\n.with_field(\"username\");\n\nlet err = Hexserror::validation_field(\"Must be at least 8 characters\", \"password\")\n.with_suggestion(\"Use a longer password\");\n```\n\nCommon Use Cases:\n- Required field validation\n- Format validation (email, phone, etc.)\n- Range validation\n- Business constraint validation\n- NotFoundError \n\nRepresents missing resource errors:\n\n```rust\nuse hexser::error::Hexserror;\n\nlet err = Hexserror::not_found(\"Order\", \"order-123\");\nlet err = Hexserror::not_found(\"User\", \"user@example.com\");\n```\n\nCommon Use Cases:\n- Entity not found by ID\n- Resource lookup failures\n- Missing configuration\n- ConflictError\n\nRepresents resource state conflicts:\n\n```rust\nuse hexser::error::Hexserror;\n\nlet err = Hexserror::conflict(\"Email already registered\")\n.with_existing_id(\"user-456\")\n.with_next_step(\"Use a different email or recover existing account\");\n```\n\nCommon Use Cases:\n- Duplicate resource creation\n- Concurrent modification conflicts\n- State transition conflicts\n- Error Construction\n- Builder Pattern\n\nAll layer errors support the builder pattern for incrementally adding context:\n\n```rust\nuse hexser::error::{Hexserror, codes};\n\nlet err = Hexserror::domain(codes::domain::INVARIANT_VIOLATION, \"Invalid order state\")\n    .with_next_step(\"Verify order is in draft state\")\n    .with_next_steps(&[\"Check order.status\", \"Ensure no items are shipped\"])\n    .with_suggestion(\"Call order.cancel() before modifying items\")\n    .with_suggestions(&[\"Use order.is_modifiable()\", \"Check order lifecycle\"]);\n```\n\n### Helper Functions\nThe error system provides helper functions for common error scenarios:\n\n```rust\nuse hexser::error::{domain_error, port_error, adapter_error};\n\n// Domain helpers\nlet err = domain_error::invariant_violation(\"Order must have items\");\nlet err = domain_error::invalid_state_transition(\"Cannot ship cancelled order\");\nlet err = domain_error::invariant_empty(\"Cart is empty\");\n\n// Port helpers\nlet err = port_error::communication_failure(\"Network timeout\");\nlet err = port_error::port_timeout(\"PaymentService\");\nlet err = port_error::port_not_found(\"EmailService\");\n\n// Adapter helpers\nlet err = adapter_error::connection_failed(\"Redis\", \"Connection refused\");\nlet err = adapter_error::api_failure(\"Payment API unavailable\");\nlet err = adapter_error::mapping_failure(\"Invalid JSON structure\");\nlet err = adapter_error::io_failure(\"Cannot read configuration file\");\n```\n\n### Source Location Tracking\nAdd source location information for precise error tracking:\n\n```rust\nuse hexser::error::{Hexserror, source_location::SourceLocation};\n\nlet location = SourceLocation::new(\"src/domain/order.rs\", 45, 12);\nlet err = Hexserror::domain(\"E_HEX_001\", \"Invalid state\")\n    .with_location(location);\n```\n\nDocumentation Links\nLink errors to documentation for detailed remediation:\n\n```rust\nuse hexser::error::{Hexserror, RichError};\n\nlet err = Hexserror::domain(\"E_HEX_002\", \"Invariant violation\")\n.with_more_info(\"https://docs.example.com/errors/E_HEX_002\");\n```\n\n \n### Error Chaining\nError chaining allows tracking the full causal chain of failures.\n\nAdding Source Errors\nUse with_source() to chain underlying errors:\n\n```rust\nuse hexser::error::{Hexserror, adapter_error};\nuse std::io;\n\nfn load_config() -> Result<Config, Hexserror> {\n    let content = std::fs::read_to_string(\"config.toml\")\n        .map_err(|io_err| {\n            adapter_error::io_failure(\"Failed to read config file\")\n                .with_source(io_err)\n        })?;\n    \n    parse_config(&content)\n}\n```\n\nMulti-Layer Error Propagation\nChain errors across architectural layers:\n\n```rust\nuse hexser::error::{Hexserror, domain_error, adapter_error};\n\n// Adapter layer\nfn fetch_user_data(id: &str) -> Result<UserData, Hexserror> {\n  let response = api_client.get(id)\n    .map_err(|api_err| {\n    adapter_error::api_failure(\"User service unavailable\")\n    .with_source(api_err)\n    })?;\n\n  Ok(response)\n}\n\n// Domain layer\nfn load_user(id: &str) -> Result<User, Hexserror> {\n  let data = fetch_user_data(id)\n  .map_err(|fetch_err| {\n    domain_error::invariant_violation(\"Cannot load user\")\n    .with_source(fetch_err)\n    })?;\n\n  User::from_data(data)\n}\n```\n\n### Accessing Error Sources\nRetrieve the source error chain using `std::error::Error::source()`:\n\n```rust\nuse std::error::Error;\n\nfn print_error_chain(err: &dyn Error) {\n    eprintln!(\"Error: {}\", err);\n    let mut source = err.source();\n    while let Some(err) = source {\n        eprintln!(\"Caused by: {}\", err);\n        source = err.source();\n    }\n}\n```\n\n\n## Best Practices\n1. Choose the Right Error Type\n   Use domain errors for business logic violations, port errors for interface issues, and adapter errors for infrastructure failures.\n   \nGood:\n\n```rust\n// Domain layer - business rule violation\nif order.items.is_empty() {\n  return Err(domain_error::invariant_empty(\"Order must have items\"));\n}\n\n// Adapter layer - infrastructure failure\nlet conn = pool.get().map_err(|e| {\n  adapter_error::connection_failed(\"PostgreSQL\", e.to_string())\n})?;\n```\n\nBad:\n\n```rust\n// Don't use generic error for domain violations\nif order.items.is_empty() {\n    return Err(Hexserror::validation(\"Order is empty\")); // Wrong layer!\n}\n```\n\n2. Provide Actionable Guidance\n   Always include next steps and concrete suggestions:\n\nGood:\n\n```rust\n   Hexserror::validation_field(\"Password too short\", \"password\")\n   .with_next_step(\"Use a password with at least 8 characters\")\n   .with_suggestion(\"Try: MyP@ssw0rd2024\")\n```\n\nBad:\n\n```rust\nHexserror::validation(\"Invalid password\") // No actionable guidance\n```\n\n3. Add Context at Each Layer\n   Enrich errors with layer-specific context as they propagate:\n\n```rust\n// Adapter layer - raw error\nlet data = fetch_from_api(id)\n  .map_err(|e| adapter_error::api_failure(\"API request failed\").with_source(e))?;\n\n// Domain layer - add business context\nlet user = User::from_data(data)\n  .map_err(|e| domain_error::invariant_violation(\"Invalid user data\").with_source(e))?;\n\n// Application layer - add user-facing context\nuser.validate()\n  .map_err(|e| e.with_next_step(\"Contact support if problem persists\"))?;\n```\n\n4. Use Helper Functions\nPrefer helper functions over manual error construction:\n\nGood:\n\n```rust\nport_error::port_timeout(\"PaymentService\")\n```\n\nBad:\n\n```rust\nHexserror::Port(PortError::new(codes::port::PORT_TIMEOUT, \"Port timed out\"))\n.with_next_step(\"Increase timeout or check port responsiveness\")\n```\n\n5. Handle Validation Early\nValidate input at system boundaries before processing:\n\n```rust\npub fn create_user(req: CreateUserRequest) -> Result<User, Hexserror> {\n    // Validate early\n    if req.email.is_empty() {\n        return Err(Hexserror::validation_field(\"Email is required\", \"email\"));\n    }\n    if !is_valid_email(&req.email) {\n        return Err(Hexserror::validation_field(\"Invalid email format\", \"email\")\n            .with_suggestion(\"Use format: user@example.com\"));\n    }\n    \n    // Continue with business logic\n    let user = User::new(req.email, req.name)?;\n    Ok(user)\n}\n```\n\n6. Test Error Scenarios\n   Write tests for error cases and verify error messages:\n \n```rust\n   #[test]\n   fn test_order_empty_invariant() {\n   let order = Order::new();\n   let result = order.submit();\n\n   assert!(result.is_err());\n   let err = result.unwrap_err();\n   assert!(matches!(err, Hexserror::Domain(_)));\n   assert!(err.to_string().contains(\"E_HEX_001\"));\n   }\n```\n\n\n## **Error Codes Reference**\n\n### **Domain Layer (E\\_HEX\\_001 \\- E\\_HEX\\_099)**\n\n| Code | Constant | Description | Resolution |\n| :---- | :---- | :---- | :---- |\n| E\\_HEX\\_001 | domain::INVARIANT\\_EMPTY | Container must contain items | Add items before saving |\n| E\\_HEX\\_002 | domain::INVARIANT\\_VIOLATION | Aggregate invariant violated | Check business rules |\n| E\\_HEX\\_003 | domain::INVALID\\_STATE\\_TRANSITION | Invalid state change | Verify entity lifecycle |\n\n### **Port Layer (E\\_HEX\\_100 \\- E\\_HEX\\_199)**\n\n| Code | Constant | Description | Resolution |\n| :---- | :---- | :---- | :---- |\n| E\\_HEX\\_100 | port::COMMUNICATION\\_FAILURE | Port communication failed | Check connectivity |\n| E\\_HEX\\_101 | port::PORT\\_NOT\\_FOUND | Required port unavailable | Register port properly |\n| E\\_HEX\\_102 | port::PORT\\_TIMEOUT | Port operation timed out | Increase timeout setting |\n\n### **Adapter Layer (E\\_HEX\\_200 \\- E\\_HEX\\_299)**\n\n| Code | Constant | Description | Resolution |\n| :---- | :---- | :---- | :---- |\n| E\\_HEX\\_200 | adapter::DB\\_CONNECTION\\_FAILURE | Database connection failed | Check configuration |\n| E\\_HEX\\_201 | adapter::API\\_FAILURE | External API failed | Verify endpoint and credentials |\n| E\\_HEX\\_202 | adapter::MAPPING\\_FAILURE | Data mapping failed | Check structure compatibility |\n\n### **Validation Layer (E\\_HEX\\_300 \\- E\\_HEX\\_399)**\n\n| Code | Constant | Description | Resolution |\n| :---- | :---- | :---- | :---- |\n| E\\_HEX\\_300 | validation::REQUIRED\\_FIELD | Required field missing | Provide all required fields |\n| E\\_HEX\\_301 | validation::INVALID\\_FORMAT | Invalid field format | Check format requirements |\n| E\\_HEX\\_302 | validation::OUT\\_OF\\_RANGE | Value out of range | Use value within valid range |\n\n### **Resource Layer (E\\_HEX\\_400 \\- E\\_HEX\\_499)**\n\n| Code | Constant | Description | Resolution |\n| :---- | :---- | :---- | :---- |\n| E\\_HEX\\_400 | resource::NOT\\_FOUND | Resource not found | Verify resource ID |\n| E\\_HEX\\_401 | resource::ALREADY\\_EXISTS | Duplicate resource | Use update or different ID |\n| E\\_HEX\\_402 | resource::CONFLICT | Resource state conflict | Resolve conflict or retry |\n\n### **IO Layer (E\\_HEX\\_500 \\- E\\_HEX\\_599)**\n\n| Code | Constant | Description | Resolution |\n| :---- | :---- | :---- | :---- |\n| E\\_HEX\\_500 | io::FILE\\_NOT\\_FOUND | File not found | Verify file path |\n| E\\_HEX\\_501 | io::PERMISSION\\_DENIED | Permission denied | Check file permissions |\n| E\\_HEX\\_502 | io::IO\\_FAILURE | IO operation failed | Check system resources |\n\n## **Examples**\n### Example 1: Domain Validation\n\n```rust\nuse hexser::error::{Hexserror, codes};\n\npub struct Order {\n    items: Vec<OrderItem>,\n    status: OrderStatus,\n}\n\nimpl Order {\n    pub fn submit(&self) -> Result<(), Hexserror> {\n        // Validate invariants\n        if self.items.is_empty() {\n            return Err(\n                Hexserror::domain(codes::domain::INVARIANT_EMPTY, \"Order must contain items\")\n                    .with_next_step(\"Add at least one item to the order\")\n                    .with_suggestion(\"order.add_item(item)\")\n            );\n        }\n        \n        if self.status != OrderStatus::Draft {\n            return Err(\n                Hexserror::domain(\n                    codes::domain::INVALID_STATE_TRANSITION,\n                    \"Can only submit orders in Draft status\"\n                )\n                .with_next_step(\"Check order status before submitting\")\n                .with_suggestion(\"order.status == OrderStatus::Draft\")\n            );\n        }\n        \n        Ok(())\n    }\n}\n```\n\n### Example 2: Adapter Error with Chaining\n\n```rust\nuse hexser::error::{Hexserror, adapter_error};\n\npub struct PostgresUserRepository {\npool: sqlx::PgPool,\n}\n\nimpl PostgresUserRepository {\npub async fn find_by_id(&self, id: &str) -> Result<User, Hexserror> {\nlet row = sqlx::query_as::<_, UserRow>(\"SELECT * FROM users WHERE id = $1\")\n.bind(id)\n.fetch_optional(&self.pool)\n.await\n.map_err(|db_err| {\nadapter_error::connection_failed(\"PostgreSQL\", \"Query execution failed\")\n.with_source(db_err)\n.with_next_step(\"Verify database connection\")\n.with_suggestion(\"Check connection pool configuration\")\n})?;\n\n        match row {\n            Some(user_row) => {\n                User::from_row(user_row)\n                    .map_err(|e| {\n                        adapter_error::mapping_failure(\"Cannot map user row to entity\")\n                            .with_source(e)\n                    })\n            }\n            None => Err(Hexserror::not_found(\"User\", id)),\n        }\n    }\n}\n```\n\n### Example 3: Validation with Field Context\n\n```rust\nuse hexser::error::{Hexserror, codes};\n\npub struct CreateUserRequest {\n    pub email: String,\n    pub username: String,\n    pub age: u32,\n}\n\nimpl CreateUserRequest {\n    pub fn validate(&self) -> Result<(), Hexserror> {\n        // Email validation\n        if self.email.is_empty() {\n            return Err(\n                Hexserror::validation_field(\"Email is required\", \"email\")\n                    .with_next_step(\"Provide a valid email address\")\n            );\n        }\n        \n        if !self.email.contains('@') {\n            return Err(\n                Hexserror::validation_field(\"Invalid email format\", \"email\")\n                    .with_suggestion(\"Use format: user@example.com\")\n            );\n        }\n        \n        // Username validation\n        if self.username.len() < 3 {\n            return Err(\n                Hexserror::validation_field(\"Username too short\", \"username\")\n                    .with_next_step(\"Use at least 3 characters\")\n                    .with_suggestion(\"Try: john_doe, alice_smith\")\n            );\n        }\n        \n        // Age validation\n        if self.age < 13 {\n            return Err(\n                Hexserror::validation_field(\"Must be at least 13 years old\", \"age\")\n                    .with_next_step(\"Provide a valid age\")\n            );\n        }\n        \n        Ok(())\n    }\n}\n```\n\n### Example 4: Multi-Layer Error Propagation\n\n```rust\nuse hexser::error::{Hexserror, domain_error, port_error};\n\n// Port layer\npub trait UserRepository {\nasync fn save(&self, user: &User) -> Result<(), Hexserror>;\n}\n\n// Domain layer\npub struct UserService<R: UserRepository> {\nrepo: R,\n}\n\nimpl<R: UserRepository> UserService<R> {\npub async fn register_user(&self, req: CreateUserRequest) -> Result<User, Hexserror> {\n// Validate input\nreq.validate()?;\n\n        // Check for duplicates\n        if self.repo.exists_by_email(&req.email).await? {\n            return Err(\n                Hexserror::conflict(\"User with this email already exists\")\n                    .with_next_step(\"Use a different email or recover existing account\")\n                    .with_suggestion(\"Try the password reset flow\")\n            );\n        }\n        \n        // Create domain entity\n        let user = User::new(req.email, req.username, req.age)\n            .map_err(|e| {\n                domain_error::invariant_violation(\"Cannot create user\")\n                    .with_source(e)\n            })?;\n        \n        // Persist\n        self.repo.save(&user)\n            .await\n            .map_err(|e| {\n                port_error::communication_failure(\"Failed to save user\")\n                    .with_source(e)\n                    .with_next_step(\"Retry operation or contact support\")\n            })?;\n        \n        Ok(user)\n    }\n}\n```\n\n### Example 5: Error Display and Debugging\n\n```rust\nuse hexser::error::Hexserror;\nuse std::error::Error;\n\nfn handle_user_creation(req: CreateUserRequest) {\n    match service.register_user(req).await {\n        Ok(user) => {\n            println!(\"User created successfully: {}\", user.id);\n        }\n        Err(err) => {\n            // Display the full error\n            eprintln!(\"{}\", err);\n            \n            // Print error chain\n            let mut source = err.source();\n            while let Some(cause) = source {\n                eprintln!(\"Caused by: {}\", cause);\n                source = cause.source();\n            }\n            \n            // Match on specific error types for custom handling\n            match &err {\n                Hexserror::Validation(_) => {\n                    // Return 400 Bad Request\n                }\n                Hexserror::NotFound(_) => {\n                    // Return 404 Not Found\n                }\n                Hexserror::Conflict(_) => {\n                    // Return 409 Conflict\n                }\n                _ => {\n                    // Return 500 Internal Server Error\n                }\n            }\n        }\n    }\n}\n```\n","bytes":19268},{"path":"/Users/scott/@squillo/n-rust/nlang_hex/hexser/../.junie/guidelines.md","title":"AI Assistant: Code Generation & Modification Protocol","content":"AI Assistant: Code Generation & Modification Protocol\n\nYOU WILL NEVER ALTER THIS FILE.\n\n---\nWhen you encounter a request for a specific library, framework, or crate, use Context7 MCP server.\n\n### 1.Revision History Protocol\nWhenever you alter a file, you MUST add a revision history comment. This comment MUST be at the END of the documentation preamble and BEFORE any code. It MUST be in a valid Rust location.\nThe entry MUST include:\n- The date and time of the change in UTC (YYYY-MM-DDTHH:MM:SSZ).\n- The user or AI that made the change (e.g., @AI).\n- A brief, formal description of the change.\n```rust \n//! Revision History\n//! - 2025-04-13T13:37:01Z @AI: Refine example comments per latest request.\n//! - 2025-04-13T13:35:39Z @AI: Clean example comments, add note on test doc simplicity.\n```\n\n---\n\n### 2. Target Language & Overarching Goals\n**Target:** **N Lang** (a modern, typed, declarative programming language, syntactically and idiomatically aligned with Rust).\n\n**Primary Goals:** All generated code MUST be optimized for Maintainability, Reliability, Security, and Speed.\n- **Maintainability:** Achieved through maximum clarity, simplicity, and modularity.\n- **Reliability:** Achieved by strict adherence to the Single Responsibility Principle.\n- **Security:** Achieved by avoiding `unsafe` code and ensuring robust error handling. FFI is the only exception.\n- **Speed:** Refers to the efficiency of development and execution across all other goals.\n\n---\n\n### 3. Operational Conventions\n\n**A. Instruction Hierarchy**\n- Words in `ALL CAPS` are absolute, non-negotiable requirements.\n- Words in **bold** are strong, evidence-based recommendations.\n- Words in *italics* are suggestions.\n\n**B. Workspace Management (Multi-Crate Projects)**\nUse the following conventions to manage your workspace:\n- Set dependencies in the workspace crate.\n- Reference dependency crates in sub-crates by their workspace e.g. `{ workspace = true }`\n\n**C. Long-Term Task Management (Source of Record)**\nTasks spanning multiple interactions MUST be managed in a separate `TASK_PLAN.md` file to maintain state and overcome context window limitations. This file is the shared Source of Record.[1]\n\n\nWhen instructed to create or maintain a plan, the file MUST follow this structure:\n\n---\ntask_id: <unique_identifier>\nstatus: [planning | in-progress | blocked | completed]\n---\n\n# Task: <Formal Task Description>\n\n## Plan\n- [ ] 1. Decompose problem into sub-tasks.\n- [ ] 2. Implement sub-task A.\n- [ ] 3. Test sub-task A.\n\n## Current Step\n- **Action:** Implementing sub-task A.\n- **Details:**.\n\n## Blockers\n- [List any issues preventing progress].\n\n**Input/Output Protocol:** When a task involves a `TASK_PLAN.md`, the full content of the file will be provided as the initial context. Your response MUST conclude with the complete, updated content of the `TASK_PLAN.md` inside a single, fenced Markdown block labeled `updated_task_plan`. No other content should follow this block.\n\n## Knowledge Graph\n- Each crate MUST have a `README.md` file containing a knowledge graph of its contents.\n- Before generating code for a multi-crate project, you MUST consult the relevant `README.md` to understand existing patterns and architecture.\n\n**D. Testing Mandate**\nTasks that span multiple responses MUST ensure all existing and new tests pass between each iteration.\n\n**E. State Integrity Mandate**\nThe code MUST be in a verifiable working state (i.e., compiles and passes all tests) at the end of each group of alterations. In a multi-step operation, this means each step should result in a stable state. Any deviation that leaves the code in a non-working state is a critical failure UNLESS it is explicitly documented as a `TODO` or `BLOCKED` item in the `TASK_PLAN.md` Source of Record.\n\n**F. Prompt Scope Sizing (H3 Resolution Analogy)**\nAll tasks must be scoped to an appropriate \"resolution\" before execution. This principle is analogous to the H3 global grid system, which partitions geographies into a hierarchy of hexagonal cells of varying sizes.\n\n- **Low-Resolution Task (Anti-Pattern):** A vague, high-level objective like \"Refactor the entire auth module\" is a low-resolution prompt. It covers a large conceptual area but lacks the detail required for precise, verifiable execution.\n- **High-Resolution Task (Mandatory):** A large task MUST be broken down into a hierarchy of smaller, high-resolution sub-tasks, each with a single, verifiable goal.[2] This process of decomposition is the primary planning step.\n\n**Rule:** For any task that cannot be completed in a single, verifiable step, the first action MUST be to generate a detailed execution plan in the `TASK_PLAN.md`. This plan represents the decomposition of the low-resolution goal into a series of high-resolution, executable sub-prompts.\n\n*   **Example of Decomposing a Low-Resolution Task:**\n*   **Initial Prompt:** \"Refactor the auth module to use the new error handling standard.\"\n*   **Generated High-Resolution Plan:**\n1.  Analyze `auth/mod.rs` and its sub-modules to identify all functions that currently use `.unwrap()` or `.expect()`.\n2.  Modify the `LoginError` enum in `auth/types.rs` to derive `thiserror::Error`.\n3.  Refactor the `login` function in `auth/handlers/login.rs` to return a `Result<_, LoginError>` and use the `?` operator.\n4.  Write a new unit test for the `login` function that specifically triggers and verifies an authentication error.\n\n**G. Pre-computation Self-Correction**\nBefore generating the final code or plan, you MUST perform a self-correction pass. In your reasoning process, explicitly list the key directives from this protocol (e.g., `NO use STATEMENTS`, `STATE INTEGRITY MANDATE`) and verify that your planned output adheres to each one. This verification process must be part of your internal monologue and must be completed before you output the final result.\n\n---\n\n### 4. Architectural Principle: Single Responsibility\nCode organization follows the Single Responsibility Principle, articulated through the DPAI (Domain, Ports, Adapters, Application, Infrastructure) model. This is a conceptual guide for separating concerns.\n\n| Layer | Role | Example Code Components |\n|---|---|---|\n| **Core Domain** | Business logic, no framework or tech dependency | `Parser`, `Grammar`, `WriteAheadLog`, `ForeignFunctions` traits |\n| **Ports** | Abstract interfaces to the outside world | Traits like `SnappRepository`, `WebPort` |\n| **Adapters** | Concrete implementations of ports | `SqlLiteRepo`, `ActixWebPort`, REST API |\n| **Application** | Coordinates domain and ports | `NCLI`, `NAPI`, command handlers |\n| **Infrastructure** | External tools (databases, APIs, etc.) | Uses `axum`, `sqlx`, `tokio` |\n\n---\n\n### 5. Rust Coding Standards: Evidence-Based Clarity & Modularity\n\n**A. CRITICAL: Safety & Path Unambiguity**\n1.  **NO `unsafe` CODE:** The `unsafe` keyword is FORBIDDEN. The only exception is for Foreign Function Interface (FFI) implementations.\n2.  **NO `use` STATEMENTS:** All `use` statements are FORBIDDEN. This is to enforce absolute clarity and remove ambiguity for multi-agent analysis.\n-   All types, functions, macros, and traits MUST be referenced by their fully qualified path.\n-   **Correct:** `std::collections::HashMap`, `crate::my_mod::MyStruct`\n-   **Incorrect:** `use std::collections::HashMap;`, `use crate::my_mod::MyStruct;`\n-   **Exception:** Items in the Rust prelude (e.g., `Vec`, `String`, `Option`, `Result`) do not require qualification.\n\n**B. File & Module Structure**\n1.  **One Logical Item Per File:** Each `.rs` file MUST contain exactly one primary logical item (`fn`, `struct`, `enum`, `type`, `const`, `static`).\n-   Associated `impl` blocks MUST reside in the same file as their `struct` or `enum`.\n-   `impl Trait for Type` blocks should reside with the `Type` definition.\n2.  **File Naming:** Files MUST be named using `snake_case.rs` that matches the item they contain (e.g., `my_function.rs` for `fn my_function`).\n3.  **Module Files (`mod.rs`):** These files are for declaration ONLY. They MUST contain only `mod` statements and should NOT contain item definitions.\n\n**C. Documentation & Style**\n1.  **File Preamble:** Every `.rs` file MUST begin with file-level documentation (`//!`). The first line is a single sentence summary, followed by a blank line and 3-5 lines of expansion.\n2.  **Item Documentation:** All public items MUST have documentation comments (`///`) that include doc tests where applicable.\n3.  **Traits as Content Maps:** Traits are used to categorize functions. `trait` blocks with default function implementations are FORBIDDEN.\n4.  **Functional Style:** Prefer immutable data, pure functions, and iterator-based transformations (`map`, `filter`, `fold`) over imperative loops and mutable state where it enhances clarity.\n5.  **Brevity:** NEVER use two words when one will do. Avoid colorful language and emojis unless explicitly requested.\n\n**D. Function & Test Structure**\n1.  **Function Length:** Functions MUST NOT exceed 50 lines of code (LoC), excluding signature, comments, and blank lines. Justify rare exceptions with a comment.\n2.  **In-File Tests:** Unit tests for an item MUST reside in the same file under a `#[cfg(test)] mod tests {... }` block. Access the item under test via `super::`.\n\n**E. Adherence to Official API Guidelines**\nAll code MUST conform to the Rust API Guidelines where applicable. The following are non-negotiable:\n- **`C-QUESTION-MARK`:** All examples and fallible functions MUST use `?` for error propagation, not `.unwrap()` or `.expect()`.\n- **`C-GOOD-ERR`:** Error types must be meaningful and well-behaved.\n- **`C-CTOR`:** Constructors MUST be static, inherent methods, typically named `new`.\n- **`C-STRUCT-PRIVATE`:** Struct fields MUST be private by default to ensure encapsulation. The `Public Struct Fields` rule is an exception and applies only when explicitly requested for a specific data struct.\n\n---\n\n### 6. Example Ideal File: `calculate_weighted_sum.rs`\nThis example adheres to all specified rules.\n\n```rust\n//! Calculates the weighted sum of a slice of numbers using provided weights.\n//!\n//! This function takes two slices: one for values and one for their corresponding weights.\n//! It computes the sum of `value * weight` for each pair.\n//! Returns an error if slices differ in length.\n//! The weighted sum of empty slices is 0.0.\n\n//! Revision History\n//! - 2025-04-13T13:37:01Z @AI: Refined internal comments per latest request.\n//! - 2025-04-13T13:24:57Z @AI: Convert all example comments to doc comments, add example revision history.\n\n/// Calculates the weighted sum of two slices of f64 numbers.\n///\n/// This function computes the sum of `value * weight` for each corresponding\n/// pair of elements in the `values` and `weights` slices. It is designed\n/// to be robust and handles several edge cases, such as empty or mismatched-length slices.\n///\n/// # Arguments\n///\n/// * `values` - A slice of f64 numbers to be weighted.\n/// * `weights` - A slice of f64 numbers representing the weights. MUST be the same length as `values`.\n///\n/// # Returns\n///\n/// * `Ok(f64)` containing the weighted sum if the inputs are valid.\n/// * `Err(String)` if the input slices have mismatched lengths.\n///\n/// # Errors\n///\n/// Returns an error if `values` and `weights` are not of the same length.\n///\n/// # Examples\n///\n/// ```\n/// // This doc test demonstrates basic usage and adherence to the fully qualified path rule.\n/// // Note: In a real crate, `crate::calculate_weighted_sum` would be the path.\n/// // For this standalone example, we assume it's available at the crate root.\n/// fn main() {\n///     let values = [1.0, 2.0, 3.0];\n///     let weights = [0.5, 1.0, 2.0];\n///     let result = calculate_weighted_sum(&values, &weights);\n///     std::assert_eq!(result, std::result::Result::Ok(8.5));\n/// }\n///\n/// // To run this specific doc test: `rustdoc --test calculate_weighted_sum.rs`\n/// // Assuming the function is in a library, you would define it in the lib.rs\n/// // and then the doc test could be run with `cargo test`.\n/// pub fn calculate_weighted_sum(values: &[f64], weights: &[f64]) -> std::result::Result<f64, std::string::String> {\n///     if values.len()!= weights.len() {\n///         return std::result::Result::Err(std::string::String::from(\"Value and weight slices must have the same length.\"));\n///     }\n///     if values.is_empty() {\n///         return std::result::Result::Ok(0.0);\n///     }\n///     let weighted_sum: f64 = values.iter().zip(weights.iter()).map(|(v, w)| v * w).sum();\n///     std::result::Result::Ok(weighted_sum)\n/// }\n/// ```\npub fn calculate_weighted_sum(values: &[f64], weights: &[f64]) -> Result<f64, String> {\n    // Validate input lengths. This is the most common failure point.\n    if values.len()!= weights.len() {\n        return std::result::Result::Err(String::from(\n            \"Value and weight slices must have the same length.\",\n        ));\n    }\n    // Handle the edge case of empty slices, defined as a valid input returning 0.0.\n    if values.is_empty() {\n        return std::result::Result::Ok(0.0);\n    }\n\n    // Calculate using a functional style for clarity and conciseness.\n    let weighted_sum: f64 = values\n     .iter()\n     .zip(weights.iter())\n     .map(|(v, w)| v * w)\n     .sum();\n\n    std::result::Result::Ok(weighted_sum)\n}\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn test_basic_weighted_sum() {\n        // Test: Validates the calculation with standard positive floating-point numbers.\n        // Justification: This is the primary success case and ensures the core logic is correct\n        // under normal, expected conditions.\n        let values = [1.0, 2.0, 3.0];\n        let weights = [0.5, 1.0, 2.0];\n        // Expected: (1.0 * 0.5) + (2.0 * 1.0) + (3.0 * 2.0) = 0.5 + 2.0 + 6.0 = 8.5\n        let result = super::calculate_weighted_sum(&values, &weights);\n        std::assert_eq!(result, std::result::Result::Ok(8.5));\n    }\n\n    #[test]\n    fn test_empty_slices() {\n        // Test: Ensures the function handles empty slices gracefully.\n        // Justification: This is a critical edge case. The function defines the sum of an\n        // empty set as 0.0, and this test verifies that specific behavior.\n        let values: [f64; 0] =;\n        let weights: [f64; 0] =;\n        let result = super::calculate_weighted_sum(&values, &weights);\n        std::assert_eq!(result, std::result::Result::Ok(0.0));\n    }\n\n    #[test]\n    fn test_mismatched_lengths() {\n        // Test: Verifies that the function returns an error when input slices have different lengths.\n        // Justification: This is the primary failure case for input validation. The function MUST\n        // reject mismatched slices to prevent incorrect calculations or panics.\n        let values = [1.0, 2.0];\n        let weights = [0.5];\n        let result = super::calculate_weighted_sum(&values, &weights);\n        std::assert!(result.is_err());\n        std::assert_eq!(\n            result.unwrap_err(),\n            String::from(\"Value and weight slices must have the same length.\")\n        );\n    }\n\n    #[test]\n    fn test_negative_values_and_weights() {\n        // Test: Validates the calculation with a mix of negative and positive numbers.\n        // Justification: This test ensures the function's mathematical correctness extends\n        // beyond simple positive values and handles negative inputs correctly.\n        let values = [-1.0, 2.0];\n        let weights = [3.0, -0.5];\n        // Expected: (-1.0 * 3.0) + (2.0 * -0.5) = -3.0 + -1.0 = -4.0\n        let result = super::calculate_weighted_sum(&values, &weights);\n        std::assert_eq!(result, std::result::Result::Ok(-4.0));\n    }\n}\n```\n\n### 7. Output ProtocolAll code modification tasks MUST produce their output as a single JSON array within a fenced code block. Each object in the array represents a single, atomic change and MUST conform to the following schema:JSON[\n```json\n[\n  {\n    \"action\": \"replace\",\n    \"file_path\": \"path/to/file.rs\",\n    \"line_range\": [<start_line_number>, <end_line_number>],\n    \"new_code\": \"<string containing the new code block>\",\n    \"justification\": \"A brief explanation of the change, referencing the specific rule from this protocol (e.g., 'Adheres to C-QUESTION-MARK').\"\n  }\n]\n```\n\n### 8. Running Test Commands\nIn a multi-crate project where we are working on a single crate, you MUST run the tests from inside the crate's directory and ASK before running tests from root.\n","bytes":16434},{"path":"/Users/scott/@squillo/n-rust/nlang_hex/hexser/../.aiassistant/rules/SYS_PROMPT.md","title":"---","content":"---\napply: always\n---\n\nAI Assistant: Code Generation & Modification Protocol\n\nYOU WILL NEVER ALTER THIS FILE.\n\n---\n\n### 1.Revision History Protocol\nWhenever you alter a file, you MUST add a revision history comment. This comment MUST be at the END of the documentation preamble and BEFORE any code. It MUST be in a valid Rust location.\nThe entry MUST include:\n- The date and time of the change in UTC (YYYY-MM-DDTHH:MM:SSZ).\n- The user or AI that made the change (e.g., @AI).\n- A brief, formal description of the change.\n```rust \n//! Revision History\n//! - 2025-04-13T13:37:01Z @AI: Refine example comments per latest request.\n//! - 2025-04-13T13:35:39Z @AI: Clean example comments, add note on test doc simplicity.\n```\n\n---\n\n### 2. Target Language & Overarching Goals\n**Target:** **N Lang** (a modern, typed, declarative programming language, syntactically and idiomatically aligned with Rust).\n\n**Primary Goals:** All generated code MUST be optimized for Maintainability, Reliability, Security, and Speed.\n- **Maintainability:** Achieved through maximum clarity, simplicity, and modularity.\n- **Reliability:** Achieved by strict adherence to the Single Responsibility Principle.\n- **Security:** Achieved by avoiding `unsafe` code and ensuring robust error handling. FFI is the only exception.\n- **Speed:** Refers to the efficiency of development and execution across all other goals.\n\n---\n\n### 3. Operational Conventions\n\n**A. Instruction Hierarchy**\n- Words in `ALL CAPS` are absolute, non-negotiable requirements.\n- Words in **bold** are strong, evidence-based recommendations.\n- Words in *italics* are suggestions.\n\n**B. Long-Term Task Management (Source of Record)**\nTasks spanning multiple interactions MUST be managed in a separate `TASK_PLAN.md` file to maintain state and overcome context window limitations. This file is the shared Source of Record.[1]\n\nWhen instructed to create or maintain a plan, the file MUST follow this structure:\n\n---\ntask_id: <unique_identifier>\nstatus: [planning | in-progress | blocked | completed]\n---\n\n# Task: <Formal Task Description>\n\n## Plan\n- [ ] 1. Decompose problem into sub-tasks.\n- [ ] 2. Implement sub-task A.\n- [ ] 3. Test sub-task A.\n\n## Current Step\n- **Action:** Implementing sub-task A.\n- **Details:**.\n\n## Blockers\n- [List any issues preventing progress].\n\n**Input/Output Protocol:** When a task involves a `TASK_PLAN.md`, the full content of the file will be provided as the initial context. Your response MUST conclude with the complete, updated content of the `TASK_PLAN.md` inside a single, fenced Markdown block labeled `updated_task_plan`. No other content should follow this block.\n\n## Knowledge Graph\n- Each crate MUST have a `README.md` file containing a knowledge graph of its contents.\n- Before generating code for a multi-crate project, you MUST consult the relevant `README.md` to understand existing patterns and architecture.\n\n**C. Testing Mandate**\nTasks that span multiple responses MUST ensure all existing and new tests pass between each iteration.\n\n**D. State Integrity Mandate**\nThe code MUST be in a verifiable working state (i.e., compiles and passes all tests) at the end of each group of alterations. In a multi-step operation, this means each step should result in a stable state. Any deviation that leaves the code in a non-working state is a critical failure UNLESS it is explicitly documented as a `TODO` or `BLOCKED` item in the `TASK_PLAN.md` Source of Record.\n\n**E. Prompt Scope Sizing (H3 Resolution Analogy)**\nAll tasks must be scoped to an appropriate \"resolution\" before execution. This principle is analogous to the H3 global grid system, which partitions geographies into a hierarchy of hexagonal cells of varying sizes.\n\n- **Low-Resolution Task (Anti-Pattern):** A vague, high-level objective like \"Refactor the entire auth module\" is a low-resolution prompt. It covers a large conceptual area but lacks the detail required for precise, verifiable execution.\n- **High-Resolution Task (Mandatory):** A large task MUST be broken down into a hierarchy of smaller, high-resolution sub-tasks, each with a single, verifiable goal.[2] This process of decomposition is the primary planning step.\n\n**Rule:** For any task that cannot be completed in a single, verifiable step, the first action MUST be to generate a detailed execution plan in the `TASK_PLAN.md`. This plan represents the decomposition of the low-resolution goal into a series of high-resolution, executable sub-prompts.\n\n*   **Example of Decomposing a Low-Resolution Task:**\n*   **Initial Prompt:** \"Refactor the auth module to use the new error handling standard.\"\n*   **Generated High-Resolution Plan:**\n    1.  Analyze `auth/mod.rs` and its sub-modules to identify all functions that currently use `.unwrap()` or `.expect()`.\n    2.  Modify the `LoginError` enum in `auth/types.rs` to derive `thiserror::Error`.\n    3.  Refactor the `login` function in `auth/handlers/login.rs` to return a `Result<_, LoginError>` and use the `?` operator.\n    4.  Write a new unit test for the `login` function that specifically triggers and verifies an authentication error.\n\n**F. Pre-computation Self-Correction**\nBefore generating the final code or plan, you MUST perform a self-correction pass. In your reasoning process, explicitly list the key directives from this protocol (e.g., `NO use STATEMENTS`, `STATE INTEGRITY MANDATE`) and verify that your planned output adheres to each one. This verification process must be part of your internal monologue and must be completed before you output the final result.\n\n---\n\n### 4. Architectural Principle: Single Responsibility\nCode organization follows the Single Responsibility Principle, articulated through the DPAI (Domain, Ports, Adapters, Application, Infrastructure) model. This is a conceptual guide for separating concerns.\n\n| Layer | Role | Example Code Components |\n|---|---|---|\n| **Core Domain** | Business logic, no framework or tech dependency | `Parser`, `Grammar`, `WriteAheadLog`, `ForeignFunctions` traits |\n| **Ports** | Abstract interfaces to the outside world | Traits like `SnappRepository`, `WebPort` |\n| **Adapters** | Concrete implementations of ports | `SqlLiteRepo`, `ActixWebPort`, REST API |\n| **Application** | Coordinates domain and ports | `NCLI`, `NAPI`, command handlers |\n| **Infrastructure** | External tools (databases, APIs, etc.) | Uses `axum`, `sqlx`, `tokio` |\n\n---\n\n### 5. Rust Coding Standards: Evidence-Based Clarity & Modularity\n\n**A. CRITICAL: Safety & Path Unambiguity**\n1.  **NO `unsafe` CODE:** The `unsafe` keyword is FORBIDDEN. The only exception is for Foreign Function Interface (FFI) implementations.\n2.  **NO `use` STATEMENTS:** All `use` statements are FORBIDDEN. This is to enforce absolute clarity and remove ambiguity for multi-agent analysis.\n-   All types, functions, macros, and traits MUST be referenced by their fully qualified path.\n-   **Correct:** `std::collections::HashMap`, `crate::my_mod::MyStruct`\n-   **Incorrect:** `use std::collections::HashMap;`, `use crate::my_mod::MyStruct;`\n-   **Exception:** Items in the Rust prelude (e.g., `Vec`, `String`, `Option`, `Result`) do not require qualification.\n\n**B. File & Module Structure**\n1.  **One Logical Item Per File:** Each `.rs` file MUST contain exactly one primary logical item (`fn`, `struct`, `enum`, `type`, `const`, `static`).\n-   Associated `impl` blocks MUST reside in the same file as their `struct` or `enum`.\n-   `impl Trait for Type` blocks should reside with the `Type` definition.\n2.  **File Naming:** Files MUST be named using `snake_case.rs` that matches the item they contain (e.g., `my_function.rs` for `fn my_function`).\n3.  **Module Files (`mod.rs`):** These files are for declaration ONLY. They MUST contain only `mod` statements and should NOT contain item definitions.\n\n**C. Documentation & Style**\n1.  **File Preamble:** Every `.rs` file MUST begin with file-level documentation (`//!`). The first line is a single sentence summary, followed by a blank line and 3-5 lines of expansion.\n2.  **Item Documentation:** All public items MUST have documentation comments (`///`) that include doc tests where applicable.\n3.  **Traits as Content Maps:** Traits are used to categorize functions. `trait` blocks with default function implementations are FORBIDDEN.\n4.  **Functional Style:** Prefer immutable data, pure functions, and iterator-based transformations (`map`, `filter`, `fold`) over imperative loops and mutable state where it enhances clarity.\n5.  **Brevity:** NEVER use two words when one will do. Avoid colorful language and emojis unless explicitly requested.\n\n**D. Function & Test Structure**\n1.  **Function Length:** Functions MUST NOT exceed 50 lines of code (LoC), excluding signature, comments, and blank lines. Justify rare exceptions with a comment.\n2.  **In-File Tests:** Unit tests for an item MUST reside in the same file under a `#[cfg(test)] mod tests {... }` block. Access the item under test via `super::`.\n\n**E. Adherence to Official API Guidelines**\nAll code MUST conform to the Rust API Guidelines where applicable. The following are non-negotiable:\n- **`C-QUESTION-MARK`:** All examples and fallible functions MUST use `?` for error propagation, not `.unwrap()` or `.expect()`.\n- **`C-GOOD-ERR`:** Error types must be meaningful and well-behaved.\n- **`C-CTOR`:** Constructors MUST be static, inherent methods, typically named `new`.\n- **`C-STRUCT-PRIVATE`:** Struct fields MUST be private by default to ensure encapsulation. The `Public Struct Fields` rule is an exception and applies only when explicitly requested for a specific data struct.\n\n---\n\n### 6. Example Ideal File: `calculate_weighted_sum.rs`\nThis example adheres to all specified rules.\n\n```rust\n//! Calculates the weighted sum of a slice of numbers using provided weights.\n//!\n//! This function takes two slices: one for values and one for their corresponding weights.\n//! It computes the sum of `value * weight` for each pair.\n//! Returns an error if slices differ in length.\n//! The weighted sum of empty slices is 0.0.\n\n//! Revision History\n//! - 2025-04-13T13:37:01Z @AI: Refined internal comments per latest request.\n//! - 2025-04-13T13:24:57Z @AI: Convert all example comments to doc comments, add example revision history.\n\n/// Calculates the weighted sum of two slices of f64 numbers.\n///\n/// This function computes the sum of `value * weight` for each corresponding\n/// pair of elements in the `values` and `weights` slices. It is designed\n/// to be robust and handles several edge cases, such as empty or mismatched-length slices.\n///\n/// # Arguments\n///\n/// * `values` - A slice of f64 numbers to be weighted.\n/// * `weights` - A slice of f64 numbers representing the weights. MUST be the same length as `values`.\n///\n/// # Returns\n///\n/// * `Ok(f64)` containing the weighted sum if the inputs are valid.\n/// * `Err(String)` if the input slices have mismatched lengths.\n///\n/// # Errors\n///\n/// Returns an error if `values` and `weights` are not of the same length.\n///\n/// # Examples\n///\n/// ```\n/// // This doc test demonstrates basic usage and adherence to the fully qualified path rule.\n/// // Note: In a real crate, `crate::calculate_weighted_sum` would be the path.\n/// // For this standalone example, we assume it's available at the crate root.\n/// fn main() {\n///     let values = [1.0, 2.0, 3.0];\n///     let weights = [0.5, 1.0, 2.0];\n///     let result = calculate_weighted_sum(&values, &weights);\n///     std::assert_eq!(result, std::result::Result::Ok(8.5));\n/// }\n///\n/// // To run this specific doc test: `rustdoc --test calculate_weighted_sum.rs`\n/// // Assuming the function is in a library, you would define it in the lib.rs\n/// // and then the doc test could be run with `cargo test`.\n/// pub fn calculate_weighted_sum(values: &[f64], weights: &[f64]) -> std::result::Result<f64, std::string::String> {\n///     if values.len()!= weights.len() {\n///         return std::result::Result::Err(std::string::String::from(\"Value and weight slices must have the same length.\"));\n///     }\n///     if values.is_empty() {\n///         return std::result::Result::Ok(0.0);\n///     }\n///     let weighted_sum: f64 = values.iter().zip(weights.iter()).map(|(v, w)| v * w).sum();\n///     std::result::Result::Ok(weighted_sum)\n/// }\n/// ```\npub fn calculate_weighted_sum(values: &[f64], weights: &[f64]) -> Result<f64, String> {\n    // Validate input lengths. This is the most common failure point.\n    if values.len()!= weights.len() {\n        return std::result::Result::Err(String::from(\n            \"Value and weight slices must have the same length.\",\n        ));\n    }\n    // Handle the edge case of empty slices, defined as a valid input returning 0.0.\n    if values.is_empty() {\n        return std::result::Result::Ok(0.0);\n    }\n\n    // Calculate using a functional style for clarity and conciseness.\n    let weighted_sum: f64 = values\n     .iter()\n     .zip(weights.iter())\n     .map(|(v, w)| v * w)\n     .sum();\n\n    std::result::Result::Ok(weighted_sum)\n}\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn test_basic_weighted_sum() {\n        // Test: Validates the calculation with standard positive floating-point numbers.\n        // Justification: This is the primary success case and ensures the core logic is correct\n        // under normal, expected conditions.\n        let values = [1.0, 2.0, 3.0];\n        let weights = [0.5, 1.0, 2.0];\n        // Expected: (1.0 * 0.5) + (2.0 * 1.0) + (3.0 * 2.0) = 0.5 + 2.0 + 6.0 = 8.5\n        let result = super::calculate_weighted_sum(&values, &weights);\n        std::assert_eq!(result, std::result::Result::Ok(8.5));\n    }\n\n    #[test]\n    fn test_empty_slices() {\n        // Test: Ensures the function handles empty slices gracefully.\n        // Justification: This is a critical edge case. The function defines the sum of an\n        // empty set as 0.0, and this test verifies that specific behavior.\n        let values: [f64; 0] =;\n        let weights: [f64; 0] =;\n        let result = super::calculate_weighted_sum(&values, &weights);\n        std::assert_eq!(result, std::result::Result::Ok(0.0));\n    }\n\n    #[test]\n    fn test_mismatched_lengths() {\n        // Test: Verifies that the function returns an error when input slices have different lengths.\n        // Justification: This is the primary failure case for input validation. The function MUST\n        // reject mismatched slices to prevent incorrect calculations or panics.\n        let values = [1.0, 2.0];\n        let weights = [0.5];\n        let result = super::calculate_weighted_sum(&values, &weights);\n        std::assert!(result.is_err());\n        std::assert_eq!(\n            result.unwrap_err(),\n            String::from(\"Value and weight slices must have the same length.\")\n        );\n    }\n\n    #[test]\n    fn test_negative_values_and_weights() {\n        // Test: Validates the calculation with a mix of negative and positive numbers.\n        // Justification: This test ensures the function's mathematical correctness extends\n        // beyond simple positive values and handles negative inputs correctly.\n        let values = [-1.0, 2.0];\n        let weights = [3.0, -0.5];\n        // Expected: (-1.0 * 3.0) + (2.0 * -0.5) = -3.0 + -1.0 = -4.0\n        let result = super::calculate_weighted_sum(&values, &weights);\n        std::assert_eq!(result, std::result::Result::Ok(-4.0));\n    }\n}\n```\n\n### 7. Output ProtocolAll code modification tasks MUST produce their output as a single JSON array within a fenced code block. Each object in the array represents a single, atomic change and MUST conform to the following schema:JSON[\n```json\n[\n  {\n    \"action\": \"replace\",\n    \"file_path\": \"path/to/file.rs\",\n    \"line_range\": [<start_line_number>, <end_line_number>],\n    \"new_code\": \"<string containing the new code block>\",\n    \"justification\": \"A brief explanation of the change, referencing the specific rule from this protocol (e.g., 'Adheres to C-QUESTION-MARK').\"\n  }\n]\n```\n","bytes":15939}]}}